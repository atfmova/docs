- [نصب در جاوا اسکریپت](#menu)
- [نصب در IOS](#menu)
- [نصب در Android](#menu)
- [نصب در java](#menu)
- [مدیریت مخاطبین](#menu)
- [مدیریت ترد ها](#menu)
- [مدیریت پیام ها](#menu)
- [مکانیزم Seen برای پیام ها](#menu)
- [مدیریت Cache](#menu)
- [مدیریت فایل ها](#menu)
- [مدیریت پروفایل](#menu)
- [Event Listeners](#menu)
- [آدرس ها و تنظیمات](#menu)
- [موقعیت و مسیریابی](#menu)
- [لینک‌های مرتبط](#menu)



## نصب در جاوا اسکریپت

در صورتی که npm را نصب دارید، میتوانید با خط دستور زیر سرویس پیام رسان را بر روی پروژه ی خود نصب نمایید.

<br/>

**npm install podchat --save**

یا از طریق لینک زیر اقدام به دریافت فایل زیپ پروژه نمایید و آن را در محل پروژه ی خود extract کنید:

<br/>

[لینک گیت هاب](https://github.com/FanapSoft/podchat)

[لینک npm](https://www.npmjs.com/package/podchat)

#### پیش نیاز ها:
هر کاربر جهت ورود نیازمند به یک توکن دسترسی است.

<br/>
توکن دسترسی باید قبل از استفاده از سرویس پیام رسان ، از سرور sso دریافت شود تا به هنگام ساخت نمونه ی اولیه از شیء این سرویس به عنوان پارامتر به آن داده شود.

#### ساخت نمونه اولیه:

اولین قدم ساخت یک شیء نمونه از ماژول چت است.

``` javascript
var ChatSdk = require('podchat');

//params doc => https://docs.pod.ir/document/chat-javascript-config
var Chat = new ChatSdk(params),

```
<br/>
آدرس ها و تنظیمات لازم را به صورت لیستی از پارامترها به عنوان params به ورودی نمونه خود بدهید.

``` javascript
var params = {
    appId: new Date().getTime(),
    socketAddress: 'ws://172.16.110.131:8003/ws', // {**REQUIRED**} Socket Address
    ssoHost: 'http://172.16.110.76', // {**REQUIRED**} Socket Address
    platformHost: 'http://172.16.110.131:8080', // {**REQUIRED**} Platform Core Address
    fileServer: 'http://172.16.110.131:8080', // {**REQUIRED**} File Server Address
    serverName: 'chat-server2', // {**REQUIRED**} Server to to register on
    grantDeviceIdFromSSO: false,
    enableCache: false, // Enable Client side caching
    fullResponseObject: true,
    mapApiKey: 'NESHAN_MAP_API_KEY',
    typeCode: "default",
    token: '7cba09ff83554fc98726430c30afcfc6', // {**REQUIRED**} SSO Token 
    wsConnectionWaitTime: 500, // Time out to wait for socket to get ready after open
    connectionRetryInterval: 5000, // Time interval to retry registering device or registering server
    connectionCheckTimeout: 10000, // Socket connection live time on server
    messageTtl: 24 * 60 * 60, // Message time to live (1 day in seonds)
    reconnectOnClose: true, // auto connect to socket after socket close
    asyncLogging: {
        onFunction: true, // log main actions on console
        onMessageReceive: true, // log received messages on console
        onMessageSend: true, // log sent messaged on console
        actualTiming: true // log actual functions running time
    }
}
```

<div class="box-end">
</div>

## نصب در IOS

پکیج iOS چت را میتوانید با استفاده از لینک زیر، از گیت هاب دریافت کنید.

[لینک گیت هاب](https://github.com/smartPodLand/Pod-Chat-iOS-SDK)

### راهنمای نصب و استفاده در Xcode

روژه ی خود را در Xcode باز کنید.
پکیج دانلود شده را روی پروژه ی خود، بصورت drag and drop بکشید.
دقت کنید که تیک گزینه ی Copy items if needed رو فعال کرده، سپس Finish را بزنید.
در قسمت Navigator ، پروژه ی خود را انتخاب کنید.
تب Build Phases را باز کنید.
منوی Link Binary With Libraries را انتخاب کنید.
گزینه ی + را کلیک کنید.
پکیج Chat.framework را پیدا کرده و Add کنید.

<br/>
دقت کنید که باید دستور زیر را در ابتدای سورس کد خود اضافه کنید:

``` javascript
import FanapPodChatSDK
```
<br/>

#### پیش نیاز ها:
ابتدا باید اجازه ی دسترسی درخواست های HTTP به به اپلیکیشن داده شود.

Navigator -> Info.plist (right-click) -> Open As -> Source Code

حالا کد زیر را اضافه کرده و به جای عبارت “YourDomainName” ، آدرس دامین خود را (که درخواست های HTTP به آن زده میشوند) جایگذاری کنید.

``` java
<key>NSAppTransportSecurity</key>
    <dict>
	<key>NSAllowsArbitraryLoads</key>
	<true/>
	<key>NSExceptionDomains</key>
	<dict>
	    <key>YourDomainName</key>
	    <dict>
		<key>NSExceptionAllowsInsecureHTTPLoads</key>
		<true/>
		<key>NSIncludesSubdomains</key>
		<true/>
	    </dict>
	</dict>
    </dict>
```
هر کاربر جهت ورود نیازمند به یک توکن دسترسی است.

توکن دسترسی باید قبل از استفاده از پکیج چت، از سرور sso دریافت شود تا هنگام ساخت نمونه ی اولیه از شیء چت، به عنوان پارامتر به آن داده شود.

#### ساخت نمونه اولیه:
اولین قدم، ساخت یک شیء ، از ماژول چت است.

ابتدا یک property برای نگهداری شیء از چت می سازید:


``` javascript
var myChatObject: Chat?
```
سپس چت را با استفاده از پارامتر های ورودی مورد نیاز (آدرس ها و تنظیمات) بسازید:


``` javascript
 myChatObject = Chat(پارامتر های ورودی مورد نیاز را در این جا باید قرار دهید)
```
**مثال**:

``` javascript
myChatObject = Chat(socketAddress:		String,		// Socket Address
                     ssoHost:			String,		// SSO Host Address
                     platformHost:		String,		// PlatForm Address
                     fileServer:		String,		// File Server Address
                     serverName:		String,		// name of your chat server
                     token:			String,		// user TOKEN
                     mapApiKey:			String?,	// 
                     mapServer:			String,		// Map Server Address
                     typeCode:			String?,	// 
                     enableCache:		Bool,		// Do you want to use cache?
                     cacheTimeStampInSec:	Int?,		// How long does the participant objects lives on the Cache
                     msgPriority:		Int?,		//
                     msgTTL:			Int?,		//
                     httpRequestTimeout:	Int?,		//
                     actualTimingLog:		Bool?,		//
                     wsConnectionWaitTime:	Double,		//
                     connectionRetryInterval:	Int,		//
                     connectionCheckTimeout:	Int,		//
                     messageTtl:		Int,		//
                     reconnectOnClose:		Bool)		// Do you want to reconnect if connection lost?
```
بعد از ساختن چت، باید ChatDelegates را به انتهای تعریف کلاس خود اضافه کنید.
سپس این خط را به کد خود اضافه کنید:

``` javascript
 myChatObject?.delegate = self
```
حالا باید متدهای ضروری ChatDelegates را پیاده سازی کنید:

``` javascript
    func chatConnected() {
        // do your implementation
    }
    
    func chatReconnect() {
        // do your implementation 
    }
    
    func chatThreadEvents() {
        // do your implementation
    }
    
    func chatReady() {
        // do your implementation 
    }
    
    func chatError(errorCode: Int, errorMessage: String, errorResult: Any?) {
        // do your implementation
    }
    
    func chatState(state: Int) {
        // do your implementation
    }
    
    func chatDeliver(messageId: Int, ownerId: Int) {
        // do your implementation
    }
    
    func messageEvents(type: String, result: JSON) {
        // do your implementation
    }
    
    func threadEvents(type: String, result: JSON) {
        // do your implementation
    }
```

<div class="box-end">
</div>

## نصب در Android

پکیج اندرویدی چت را میتوانید از لینک زیر با استفاده از گیت دریافت کنید یا فایل زیپ آن را دانلود نمایید.

[لینک گیت هاب](https://github.com/smartPodLand/Pod-Chat-Android-SDK)

#### راهنمای نصب با استفاده از Android Studio:

چت Sdk به صورت یک ماژول مستقل نیز از طریق maven  قابل دسترس است.
با اضافه کردن در app/build.gradle در قسمت dependencies می توانید نیز به پروژه ی خود اضافه کنید.

``` java
dependencies { 
implementation 'com.fanap.chat:podchat:0.4.2.4' }
```
<br/>

#### پیش نیاز ها:
- دسترسی اینترنت به اپلیکیشن باید داده شود. خط زیر را به فایل AndroidManifest.xml پروژه خود اضافه کنید:

``` java
<uses-permission android:name="android.permission.INTERNET" />
```

- هر کاربر جهت ورود نیازمند به یک توکن دسترسی است.
توکن دسترسی باید قبل از استفاده از پکیج چت ، از سرور sso دریافت شود تا به هنگام ساخت نمونه ی اولیه از شیء چت به عنوان پارامتر به آن داده شود.

#### ساخت نمونه اولیه:

اولین قدم ساخت یک شیء نمونه از ماژول چت است.

``` java
chat.init(context);
```
سپس ارتباط با سرور مانند مثال زیر از طریق متد connect برقرار میشود.


``` java
* @param requestConnect {
    *                       socketAddress {**REQUIRED**}
    *                       platformHost  {**REQUIRED**}
    *                       severName     {**REQUIRED**}
    *                       appId         {**REQUIRED**}
    *                       token         {**REQUIRED**}
    *                       fileServer    {**REQUIRED**}
    *                       ssoHost       {**REQUIRED**}
    *                       }
    */
RequestConnect requestConnect = new RequestConnect
            .Builder(serverAddress, appId, severName, token, ssoHost, platformHost, fileServer)
            .build();
    chat.connect(requestConnect);
```

#### آدرس ها و تنظیمات

تنظیمات و آدرس های زیر برای اتصال Async (به روی سرور سندباکس) باید به عنوان پارامتر ورودی پس از ساخت نمونه ی اولیه از پکیج، به متد connect داده شود تا اتصال با سرور انجام گیرد.

``` java
  socketServerAddress = "wss://chat-sandbox.pod.ir/ws" // {*REQUIRED*} Socket Server Address
  appId = "POD-Chat"  // {*REQUIRED*} Application Id
  ssoHost = "https://accounts.pod.ir" // {*REQUIRED*} SSO Server Address
  platformHost = "https://sandbox.pod.ir:8043/srv/basic-platform" // {*REQUIRED*} Platform Server Address
  fileServer = "https://sandbox.pod.ir:8443/" // {*REQUIRED*} File Server Address
  serverName = "chat-server" // {*REQUIRED*} Server to register on
  token = "CLIENT_ACCESS_TOKEN" // {*REQUIRED*} SSO Token

chat.connect(socketServerAddress, appId, serverName, token , ssoHost, platformHost, fileServer)

```

در نهایت نمونه ی ساخته شده آماده ی استفاده است.

با قرار دادن true در لاگ به شما لاگ خام بدون تغییرات را نشان می دهد. توصیه می شود در هنگام توسعه این لاگ را فعال کنید.


``` java
chat.rawLog(boolean rawLog);
```
با قرار دادن مقدار زمانی که میخواهید هنگام فرستادن سیگنال هایی مانند is_typing  هر چند ثانیه سینگال مخصوص را می فرستد.

``` java
chat.signalIntervalTime(int Second)
```

قابلیت کش را فراهم می کند.

``` java
chat.isCacheables(boolean cache);
```
لاگ را برای تمام جواب ها و ریکویست ها نشان می دهد.

``` java
chat.isLoggable(boolean log);
```


<div class="box-end">
</div>

## نصب در java

پکیج جاوا چت را میتوانید از لینک زیر با استفاده از گیت دریافت کنید یا فایل زیپ آن را دانلود نمایید.

[لینک گیت هاب](https://github.com/smartPodLand/Pod-Chat-Java-SDK)

#### پیش نیاز ها:

هر کاربر جهت ورود نیازمند به یک توکن دسترسی است

توکن دسترسی باید قبل از استفاده از سرویس پیام رسان ، از سرور sso دریافت شود تا به هنگام ساخت نمونه ی اولیه از شیء این سرویس به عنوان پارامتر به آن داده شود.

#### ساخت نمونه اولیه:

اولین قدم ساخت یک شیء نمونه از ماژول چت است.

``` java
Chat.init(true);
```
 سپس ارتباط با سرور مانند مثال زیر از طریق متد connect برقرار میشود.


``` java
* @param requestConnect {
     *                       queueServer      {**REQUIRED**}
     *                       queuePort         {**REQUIRED**}
     *                       queueInput        {**REQUIRED**}
     *                       queueOutput      {**REQUIRED**}
     *                       queueUserName {**REQUIRED**}
     *                       queuePassword  {**REQUIRED**}
     *                       serverName      {**REQUIRED**}
     *                       token              {**REQUIRED**}
     *                       ssoHost           {**REQUIRED**}
     *                       platformHost   {**REQUIRED**}
     *                       fileServer       {**REQUIRED**}
     *                       }
     */
RequestConnect requestConnect = new RequestConnect
                .Builder(queueServer, queuePort, queueInput, queueOutput, queueUserName, queuePassword, serverName, token, ssoHost, platformHost, fileServer)
                .build();
       
 chat.connect(requestConnect);
```

<div class="box-end">
</div>


## مدیریت مخاطبین

### دریافت لیست مخاطبین


<div class="tab-start">
</div>


# [IOS](#tab/ios)

``` java

// Request
// an example of getContact request:

// this is the model that you have to create to pass it through the "getContacts" method
let inputModel = GetContactsRequestModel(count:     5,    //
                                         offset:    0,    //
                                         query:     nil,  //
                                         typeCode:  nil,  //
                                         uniqueId:  nil)  //

Chat.sharedInstance.getContacts(getContactsInput: inputModel, uniqueId: { (getContactUniqueId) in
  // "getContactUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (getContactsServerResponse) in
  // this response is of type "GetContactsModel" but you have to froce cast it as below
  let myResponseModel: GetContactsModel = getContactsResponse as! GetContactsModel

}, cacheResponse: { (getContactsCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "GetContactsModel". (there is no need to cast is as sth...)
})

```

# [Android](#tab/android)

``` java

count = 50;
offset = 0;

 RequestGetContact requestGetContact = new RequestGetContact.Builder()
                .count()
                .offset()
                .build();
 chat.getContacts(requestGetContact,null);


```

# [JavaScript](#tab/javascript)

``` javascript

var Params = {
   count: 50, //{**OPTIONAL**}
   offset: 0  //{**OPTIONAL**}
};

Chat.getContacts(Params, function(contactsResult) {
    console.log(contactsResult);
  });

```


<div class="tab-end">
</div>

<br/>

### اضافه کردن یک مخاطب جدید


<div class="tab-start">
</div>


# [IOS](#tab/ios)

``` java

// Request
// an example of addContact request:

// this is the model that you have to create to pass it through the "addContacts" method
let inputModel = AddContactsRequestModel(cellphoneNumber:  "0935****350", //
                                         email:            nil,           // 
                                         firstName:        "Mahyar",      //
                                         lastName:         "Akbarian",    //
                                         typeCode:         nil,           //
                                         uniqueId:         nil)           //

Chat.sharedInstance.addContact(addContactsInput: inputModel, uniqueId: { (addContactUniqueId) in
	// "addContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (myResponse) in
	// this response is of type "ContactModel" but you have to froce cast it as below
	let myResponseModel: ContactModel = addContactResponse as! ContactModel
})

```

# [Android](#tab/android)

``` java
  /**
 	* Add one contact to the contact list
 	*
 	* @param request {
 	*            	firstName   	Notice: if just put fistName without lastName its ok.
 	*            	lastName    	last name of the contact
 	*            	cellphoneNumber Notice: If you just  put the cellPhoneNumber doesn't necessary to add email
 	*            	email       	email of the contact
 	*            	}
 	*/
   	  RequestAddContact requestAddContact = new RequestAddContact.Builder()
            	.firstName()
            	.lastName()
            	.cellphoneNumber()
            	.email()
            	.build();
    	chat.addContact(requestAddContact);


```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.addContacts({
    firstName: "Sina",
    lastName: "Rahimi",
    cellphoneNumber: "0912*****85",
    email: "sinarahimi1@gmail.com"
  }, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### به روز رسانی کاربر


<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java

// Request
// an example of updateContact request:

// this is the model that you have to create to pass it through the "updateContacts" method
let inputModel = UpdateContactsRequestModel(cellphoneNumber:  "0935****233",    //
                                            email:            "mehyar@me.com",  //
                                            firstName:        "Sina",           //
                                            id:               10,               //
                                            lastName:         "Rokni",          //
                                            typeCode:         nil)              //
                                            uniqueId:         nil)              //

Chat.sharedInstance.updateContact(updateContactsInput: inputModel, uniqueId: { (updateContactUniqueId) in
	// "updateContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (updateContactResponse) in
	// this response is of type "ContactModel" but you have to froce cast it as below
	let myResponseModel: ContactModel = updateContactResponse as! ContactModel
})

```

# [Android](#tab/android)

``` java

/**
 	* Update contacts
 	* All of the params all [Required]
 	*
 	* @param request {
 	*             	String firstName [Required]
 	*             	String lastName [Required]
 	*             	String cellphoneNumber [Required]
 	*             	String email [Required]
 	*             	long userId [Required]
 	*            	}
 	*/
     RequestUpdateContact requestUpdateContact = new RequestUpdateContact.Builder(userId)
            	.firstName()
            	.lastName()
            	.cellphoneNumber()
            	.email()
            	.build();
    	chat.updateContact(updateContact);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.updateContacts({
    id: "661",
    firstName: "mohammad javad",
    lastName: "Rahimi",
    cellphoneNumber: "0938*****55",
    email: "newMail@gmail.com"
  }, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### حذف کاربر


<div class="tab-start">
</div>



# [IOS](#tab/ios)

``` java

// Request
// an example of removeContact request:

// this is the model that you have to create to pass it through the "removeContacts" method
let inputModel = RemoveContactsRequestModel(id:        4121,  // id of your contact that you want to remove it
                                            typeCode:  nil)   // 
                                            uniqueId:  nil)   // 

Chat.sharedInstance.removeContact(removeContactsInput: inputModel, uniqueId: { (removeContactUniqueId) in
	// "removeContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (removeContactResponse) in
	// this response is of type "RemoveContactModel" but you have to froce cast it as below
	let myResponseModel: RemoveContactModel = removeContactResponse as! RemoveContactModel
})

```

# [Android](#tab/android)

``` java

/**
* Remove contact with the user id
*
* @param request {
*            	long userId
*            	}
*/
    RequestRemoveContact requestRemoveContact = new RequestRemoveContact.Builder(userId)
            .build();
    chat.removeContact(requestRemoveContact);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.removeContacts({
    id: "661" //{**REQUIRED**}
  }, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### syncContact


<div class="tab-start">
</div>


# [IOS](#tab/ios)

``` java
// Request
// an example of syncContact request:

Chat.sharedInstance.syncContacts(uniqueId: { (syncContactUniqueId) in
	// "syncContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (myResponse) in
	// this response is of type "ContactModel" but you have to froce cast it as below
	let myResponseModel: ContactModel = myResponse as! ContactModel
})

```

# [Android](#tab/android)

``` java
/**
* First we get the contact from server then at the respond of that
*
* @param activity its for check the permission of reading the phone contact
*             	{@link #getPhoneContact(Context)}
*/
chat.syncContact(Activity activity);


```

<div class="tab-end">
</div>

<br/>

### مسدود کردن کاربر


<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java
// Request
// an example of blockContact request:

// this is the model that you have to create to pass it through the "blockContacts" method
let inputModel = BlockContactsRequestModel(contactId:  81,   //
                                           threadId:   nil,  //
                                           userId:     nil,  //
                                           typeCode:   nil)  //
                                           uniqueId:   nil)  //

Chat.sharedInstance.blockContact(blockContactsInput: inputModel, uniqueId: { (blockContactUniqueId) in
	// "blockContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (blockContactResponse) in
	// this response is of type "BlockedContactModel" but you have to froce cast it as below
	let myResponseModel: BlockedContactModel = blockContactResponse as! BlockedContactModel
})

```

# [Android](#tab/android)

``` java
/**
* It blocks the thread
* @ param contactId id of the contact
* @ param threadId  id of the thread
* @ param userId    id of the user
*/

RequestBlock requestBlock = new RequestBlock.Builder()
        .contactId()
        .threadId()
        .userId()
        .build();
chat.block(requestBlock,null);
```

# [JavaScript](#tab/javascript)

``` javascript
  var data = {
    contactId: contactId //Required
  }

  Chat.block(data, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### گرفتن لیست کابران مسدود شده


<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java
// Request
// an example of getBlockedList request:

// this is the model that you have to create to pass it through the "getBlockedContacts" method
let inputModel = GetBlockedContactListRequestModel(count:     nil,   //
                                                   offset:    nil,   //
                                                   typeCode:  nil,   //
                                                   uniqueId:  nil)   //

Chat.sharedInstance.getBlockedContacts(getBlockedContactsInput: inputModel, uniqueId: { (getBlockedContactListUniqueId) in
	// "getBlockedContactListUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (bockedListResponse) in
	// this response is of type "GetBlockedContactListModel" but you have to froce cast it as below
	let myResponseModel: GetBlockedContactListModel = bockedListResponse as! GetBlockedContactListModel
})

```

# [Android](#tab/android)

``` java
/**
* It gets the list of the block list
*
* @param request {
*                ----- long count Number of the response
*                ----- long offset offset of the response
*                }
* @param handler Its not useful yet set it to null
*/
RequestBlockList requestBlockList = new RequestBlockList.Builder()
        .count()
        .offset()
        .build();
chat.getBlockList(requestBlockList,null);

```

# [JavaScript](#tab/javascript)

``` javascript
var data = {
    count: 50,
    offset: 0
}

Chat.getBlocked(data, function(result) {
    console.log(result);
});

```

<div class="tab-end">
</div>

<br/>

### ارتباط مجدد با کاربران مسدود شده


<div class="tab-start">
</div>


# [IOS](#tab/ios)

``` java
// Request
// an example of unblock request:

// this is the model that you have to create to pass it through the "unblockContact" method
let inputModel = UnblockContactsRequestModel(blockId:   141,	//
                                             contactId: nil,	//
                                             threadId:  nil,	//
                                             userId:    nil,	//
                                             typeCode:  nil)	//
                                             uniqueId:  nil)	//

Chat.sharedInstance.unblockContact(unblockContactsInput: inputModel, uniqueId: { (unblockContactUniqueId) in
	// "unblockContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (unblockResponse) in
	// this response is of type "BlockedContactModel" but you have to froce cast it as below
	let myResponseModel: BlockedContactModel = unblockResponse as! BlockedContactModel
})

```

# [Android](#tab/android)

``` java
  /**
     * It unblocks thread with three way
     *
     * @ param blockId it can be found in the response of getBlockList
     * @ param userId Id of the user
     * @ param threadId Id of the thread
     * @ param contactId Id of the contact
     */ 
RequestUnBlock requestUnBlock = new RequestUnBlock.Builder()
                .blockId()
                .contactId()
                .threadId()
                .userId()
                .build();
        chat.unblock(request, handler);

```

# [JavaScript](#tab/javascript)

``` javascript
  var data = {
    blockId: blockId //Required
  }
  Chat.unblock(data, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### جستجوی کاربران

<div class="tab-start">
</div>


# [IOS](#tab/ios)

``` java

// Request
// an example of searchContact request:

// this is the model that you have to create to pass it through the "searchContact" method
let inputModel = SearchContactsRequestModel(cellphoneNumber: "09368640180", //
                                            email:            nil,	        //
                                            firstName:        nil,	        //
                                            id:               nil,	        //
                                            lastName:         nil,	        //
                                            offset:           nil,	        //
                                            size:             nil,	        //
                                            typeCode:         nil,	        //
                                            uniqueId:         nil)	        //

Chat.sharedInstance.searchContacts(searchContactsInput: inputModel, uniqueId: { (searchContactsUniqueId) in
	// "searchContactsUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (serverResponse) in
	// this response is of type "GetContactsModel" but you have to froce cast it as below
	let myResponseModel: GetContactsModel = serverResponse as! GetContactsModel

}, cacheResponse: { (cacheResponse) in
	// this it the cache response of this request
	// output of this response, is of type "GetContactsModel". (there is no need to cast is as sth...)
})

```

# [Android](#tab/android)

``` java
/*
*cellphoneNumber
*email
*firstName
*lastName
*uniqueId
*id
*offset 
*size 
*typeCode
*q
*/

SearchContact searchContact = new SearchContact.Builder(string offset, string size).id(string id).build();

chat.searchContact(SearchContact searchContact);

```

# [JavaScript](#tab/javascript)

``` javascript
/*
*cellphoneNumber
*email
*firstName
*lastName
*uniqueId
*id
*offset 
*size 
*typeCode
*q
*/

  Chat.searchContacts({
    cellphoneNumber: 099
  }, function(result){
    if (!result.hasError) {
      console.log(result);
    }
  });

```

<div class="tab-end">
</div>

<div class="box-end">
</div>


## مدیریت ترد ها

### لیست تمام تردها

لیست تمام ترد های اخیرا ایجاد شده ی کاربر را به ترتیب زمانی و بر اساس متغیر های صفحه بندی (count, offset) نشان خواهد داد


<div class="tab-start">
</div>

# [java](#tab/java)

``` java

   /**
     *
     * @param creatorCoreUserId    if it sets to '0' its considered as it was'nt set   Optional]
     * @param partnerCoreUserId    if it sets to '0' its considered as it was'nt set -
     *                             it gets threads of p2p not groups   Optional]
     * @param partnerCoreContactId if it sets to '0' its considered as it was'nt set-
     *                             it gets threads of p2p not groups   Optional]
     * @param count                Count of the list   Optional]
     * @param offset               Offset of the list  [Optional]
     * @param threadIds             List of thread ids that you want to get  [Optional]
     * @param threadName            Name of the thread that you want to get  [Optional]
     */

RequestThread requestThread = new RequestThread.Builder()
.partnerCoreContactId()
.threadIds()
.threadName()
.partnerCoreContactId()
.creatorCoreUserId()
.partnerCoreUserId()
.count()
.offset()
.build();

getThreads(requestThread)
```

# [IOS](#tab/ios)

``` java

// Request
// an example of getThreads request:

// this is the model that you have to create to pass it through the "getThreads" method
let inputModel = GetThreadsRequestModel(count:                 9,    // count of threads to be received (default value is 50)
                                        creatorCoreUserId:     nil,  // SSO User Id of thread creator
                                        metadataCriteria:      nil,  //
                                        name:                  nil,  // Search term to look up in thread Titles
                                        new:                   nil,  //
                                        offset:                0,    // offset of select query (default value is 0)
                                        partnerCoreContactId:  nil,  // Contact Id of thread partner
                                        partnerCoreUserId:     nil,  // SSO User Id of thread partner
                                        threadIds:             nil,  // An array of thread ids to be received
                                        typeCode:              nil,  
                                        uniqueId:              nil) 

Chat.sharedInstance.getThreads(getThreadsInput: inputModel, uniqueId: { (getThreadUniqueId) in
  // "getThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (getThreadServerResponse) in
  // this response is of type "GetThreadsModel" but you have to froce cast it as below
  let myResponseModel: GetThreadsModel = getThreadServerResponse as! GetThreadsModel

}, cacheResponse: { (getThreadCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "GetThreadsModel". (there is no need to cast is as sth...)
})

```

# [Android](#tab/android)

``` java

   /**
     *
     * @param creatorCoreUserId    if it sets to '0' its considered as it was'nt set   Optional]
     * @param partnerCoreUserId    if it sets to '0' its considered as it was'nt set -
     *                             it gets threads of p2p not groups   Optional]
     * @param partnerCoreContactId if it sets to '0' its considered as it was'nt set-
     *                             it gets threads of p2p not groups   Optional]
     * @param count                Count of the list   Optional]
     * @param offset               Offset of the list  [Optional]
     * @param handler               Its not working yet set it to null [Optional]
     * @param threadIds             List of thread ids that you want to get  [Optional]
     * @param threadName            Name of the thread that you want to get  [Optional]
     */

RequestThread requestThread = new RequestThread.Builder()
.partnerCoreContactId()
.threadIds()
.threadName()
.partnerCoreContactId()
.creatorCoreUserId()
.partnerCoreUserId()
.count()
.offset()
.build();

getThreads(requestThread , null)

```

# [JavaScript](#tab/javascript)

``` javascript
/**
* Get Treads.
*
* This functions gets threads list
*
* @access private
*
* @param {int}       count                 count of threads to be received
* @param {int}       offset                offset of select query
* @param {array}     threadIds             An array of thread ids to be received
* @param {string}    name                  Search term to look up in thread Titles
* @param {long}      creatorCoreUserId     SSO User Id of thread creator
* @param {long}      partnerCoreUserId     SSO User Id of thread partner
* @param {long}      partnerCoreContactId  Contact Id of thread partner
* @param {function}  callback              The callback function to call after
*
* @return {object} Instant sendMessage result
*/

var Params = {
   count: 50, //{**OPTIONAL**}
   offset: 0, //{**OPTIONAL**}
   threadIds: [96,83], //{**OPTIONAL**}
   name: "Title" //{**OPTIONAL**}
};

Chat.getThreads(Params, function(threadsResult) {
    console.log(threadsResult);
  });

```

<div class="tab-end">
</div>

<br/>

### تاریخچه یک ترد

با دریافت آیدی مربوط به یک ترد ، تاریخچه ی آن را بر اساس تنظیمات صفحه بندی (count,offset) نشان خواهد داد.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
 /**
     * Gets history of the thread
     *
     * @Param count    count of the messages  [Optional]
     * @Param order    If order is empty [default = desc] and also you have two option [ asc | desc ]       [Optional]
     * @Param long threadId   Id of the thread 
     * @Param long fromTime    Start Time of the messages  [Optional]
     * @Param long fromTimeNanos  Start Time of the messages in Nano second  [Optional]
     * @Param long toTime         End time of the messages  [Optional]
     * @Param long toTimeNanos    End time of the messages  [Optional]
     * @Param @Deprecated long firstMessageId
     * @Param @Deprecated long lastMessageId
     *
     * <p>
     * threadId Id of the thread that we want to get the history
     */

RequestGetHistory requestGetHistory = new RequestGetHistory.Builder(threadId)
                .fromTime()
                .fromTimeNanos()
                .id()
                .toTime()
                .toTimeNanos()
                .build();
chat.getHistory(requestGetHistory)
```

# [IOS](#tab/ios)

``` java
// Output
// this is my getHistory response:


{
  "hasError" : false,
  "errorMessage" : "",
  "errorCode" : 0,
  "result" : {
    "hasNext" : true,
    "contentCount" : 9,
    "history" : [
      {
        "conversation" : null,
        "ownerId" : 21,
        "metaData" : null,
        "edited" : false,
        "editable" : false,
        "delivered" : null,
        "id" : 75,
        "previousId" : 74,
        "seen" : null,
        "threadId" : null,
        "uniqueId" : "A973614A-BC82-4BFC-9A3C-C920169909C4",
        "message" : "text",
        "participant" : {
          "name" : "Mohsen",
          "receiveEnable" : null,
          "email" : null,
          "lastName" : "Khorasani",
          "notSeenDuration" : 74,
          "sendEnable" : null,
          "myFriend" : null,
          "id" : 21,
          "image" : null,
          "cellphoneNumber" : null,
          "firstName" : "Mohsen",
          "online" : null,
          "contactId" : null
        },
        "time" : 1540716828351,
        "replyInfo" : null,
        "forwardInfo" : null
      }
    ],
    "nextOffset" : 1
  }
} 

```

# [Android](#tab/android)

``` java

 /**
     * Gets history of the thread
     *
     * @Param count    count of the messages  [Optional]
     * @Param order    If order is empty [default = desc] and also you have two option [ asc | desc ]       [Optional]
     * @Param long threadId   Id of the thread 
     * @Param long fromTime    Start Time of the messages  [Optional]
     * @Param long fromTimeNanos  Start Time of the messages in Nano second  [Optional]
     * @Param long toTime         End time of the messages  [Optional]
     * @Param long toTimeNanos    End time of the messages  [Optional]
     * @Param @Deprecated long firstMessageId
     * @Param @Deprecated long lastMessageId
     *
     * <p>
     * threadId Id of the thread that we want to get the history
     */

RequestGetHistory requestGetHistory = new RequestGetHistory.Builder(threadId)
                .fromTime()
                .fromTimeNanos()
                .id()
                .toTime()
                .toTimeNanos()
                .build();
chat.getHistory(requestGetHistory , null)

```

# [JavaScript](#tab/javascript)

``` javascript
/**
    * Get History.
    *
    * This functions gets history of a thread
    *
    * @access private
    *
    * @param {int}       count             Count of threads to be received
    * @param {int}       offset            Offset of select query
    * @param {long}      threadId          Id of thread to get its history
    * @param {long}      id                Id of single message to get
    * @param {long}      userId            Messages of this SSO User
    * @param {int}       messageType       Type of messages to get (types should be set by client)
    * @param {long}      fromTime          Get messages which have bigger time than given fromTime
    * @param {int}       fromTimeNanos     Get messages which have bigger time than given fromTimeNanos
    * @param {long}      toTime            Get messages which have smaller time than given toTime
    * @param {int}       toTimeNanos       Get messages which have smaller time than given toTimeNanos
    * @param {long}      senderId          Messages of this sender only
    * @param {string}    uniqueIds         Array of unique ids to retrieve
    * @param {string}    order             Order of select query (default: DESC)
    * @param {string}    query             Search term to be looked up in messages content
    * @param {object}    metadataCriteria  This JSON will be used to search in message metadata with GraphQL
    * @param {function}  callback          The callback function to call after
    *
    * @return {object} Instant result of sendMessage
    */  

var getThreadHistoryParams = {
    count: 50,
    offset: 0,
    threadId: 83, //threadId {**REQUIRED**}
    id: messageId,
    firstMessageId: 350,
    lastMessageId: 452,
    order: "ASC",
    metadataCriteria: {
      "field": "type",
      "has": "BOT_",
      "and": [{
        "field": "id",
        "is": "1534835339446"
      }]
    },
    query: "Text" // a piece of your msg, for search
  };

  Chat.getThreadHistory(getThreadHistoryParams, function(historyResult) {
    console.log(historyResult);
  });

```

<div class="tab-end">
</div>

<br/>

### ساخت یک ترد

ساخت یک ترد ، شامل ساخت ترد نفر به نفر (چت دو نفره) ، یا ترد جمعی (گروه) می باشد. در حالت عادی نحوه ی ایجاد هر دو مدل یکسان است ، تفاوت در تعداد نفرات گروه نسبت به ترد دو نفره میباشد.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/*available thread types*/
/*  int NORMAL = 0; 
 *  int OWNER_GROUP = 1; 
 *  int PUBLIC_GROUP = 2; 
 *  int CHANNEL_GROUP = 4; 
 *  int CHANNEL = 8;
*/

/*available invitee types*/
/*int TO_BE_USER_SSO_ID = 1; 
 *int TO_BE_USER_CONTACT_ID = 2; 
 *int TO_BE_USER_CELLPHONE_NUMBER = 3; 
 *int TO_BE_USER_USERNAME = 4;
 *TO_BE_USER_ID = 5  // just for p2p
*/

Invitee[] invt = new Invitee[]{new Invitee(485, 2)};
chat.createThread(threadType, invt, threadTitle);
```

# [IOS](#tab/ios)

``` java

// Request
// an example of createThread request:

// this is the model that you have to create to pass it through the "createThread" method
let inviteeArray: [Invitee] = [Invitee(id:      "099****27",                                    //
                                       idType:  InviteeVOidTypes.TO_BE_USER_CELLPHONE_NUMBER)]  //

let inputModel = CreateThreadRequestModel(description:         nil,                 //
                                          image:               nil,                 //
                                          invitees:            inviteeArray,        //
                                          metadata:            nil,                 // 
                                          title:               "New Group",         //
                                          type:                ThreadTypes.NORMAL,  //
                                          typeCode:            nil,                 //
                                          uniqueId:            nil)                 //

Chat.sharedInstance.createThread(createThreadInput: inputModel, uniqueId: { (createThreadUniqeuId) in
  // "createThreadUniqeuId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (myCreateThreadResponse) in
  // this response is of type "CreateThreadModel" but you have to froce cast it as below
  let myResponseModel: CreateThreadModel = myCreateThreadResponse as! CreateThreadModel
})

```

# [Android](#tab/android)

``` java
/*available thread types*/
/*  int NORMAL = 0; 
 *  int OWNER_GROUP = 1; 
 *  int PUBLIC_GROUP = 2; 
 *  int CHANNEL_GROUP = 4; 
 *  int CHANNEL = 8;
*/

/*available invitee types*/
/*int TO_BE_USER_SSO_ID = 1; 
 *int TO_BE_USER_CONTACT_ID = 2; 
 *int TO_BE_USER_CELLPHONE_NUMBER = 3; 
 *int TO_BE_USER_USERNAME = 4;
 *TO_BE_USER_ID = 5  // just for p2p
*/

Invitee[] invt = new Invitee[]{new Invitee(485, 2)};
chat.createThread(threadType, invt, threadTitle);

```

# [JavaScript](#tab/javascript)

``` javascript
/*available thread types*/
/*  int NORMAL; 
 *  int OWNER_GROUP; 
 *  int PUBLIC_GROUP; 
 *  int CHANNEL_GROUP; 
 *  int CHANNEL;
*/

/*available invitee types*/
/*int TO_BE_USER_SSO_ID; 
 *int TO_BE_USER_CONTACT_ID; 
 *int TO_BE_USER_CELLPHONE_NUMBER; 
 *int TO_BE_USER_USERNAME;
 *TO_BE_USER_ID  // just for p2p
*/

var createThreadParams = { 
  "title": "Thread Title Sample",
  "type": "NORMAL",
  "invitees":
  [ { "id": 323, "idType": "TO_BE_USER_CONTACT_ID" }]
}

  Chat.createThread(createThreadParams, function(createThreadResult) {
    console.log(createThreadResult);
  });

```

<div class="tab-end">
</div>

<br/>

### به روز رسانی ترد

با استفاده از این متد میتوان مشخصات ترد را (مانند عکس،نام،توضیحات و ...) آپدیت کرد.


<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java
// Request
// an example of updatrThreadInfo request:

// this is the model that you have to create to pass it through the "createThread" method
let inputModel = UpdateThreadInfoRequestModel(description:    nil,         // Description for thread
                                              image:          nil,         // URL og thread image to be set
                                              metadata:       nil,         // New Metadata to be set on thread
                                              threadId:       1113,        // Id of thread
                                              title:          "newTitle",  // New Title for thread
                                              typeCode:       nil,           
                                              uniqueId:       nil)           

Chat.sharedInstance.updateThreadInfo(updateThreadInfoInput: inputModel, uniqueId: { (updateThreadInfoUniqueId) in
  // "updateThreadInfoUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (updateThreadResponse) in
  // this response is of type "GetThreadsModel" but you have to froce cast it as below
  let myResponseModel = updateThreadResponse as! GetThreadsModel
})

```

# [Android](#tab/android)

``` java

/**
* It updates the information of the thread
* @param request {
*            	String image : image of the thread
*            	long threadId : Id of the thread
*            	String name : Name of the thread
*            	String description : Description of the thread
*            	String metadata : Metadata of the thread
*            	}
* @param handler Its not useful yet.
*          	 
*/
    RequestThreadInfo threadInfo = new RequestThreadInfo.Builder()
            .threadId()
            .description()
            .image()
            .metadat()
            .name()
            .build();
    chat.updateThreadInfo(request, null);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.updateThreadInfo({
    threadId: 1002, // Required
    image: "image/address/url/picture.jpg",
    description: "This is a sample description for my thread",
    title: "عنوان ترد",
    metadata: {
      id: 312,
      owner: "owner username",
      name: "John Doe"
    } //this is your custom metadata, in json data structure
  }, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### muteThread و unmuteThread

با دریافت آیدی ترد ، ترد مربوطه را mute میکند.

ا دریافت آیدی ترد، مشخصه ی mute ترد مربوطه را در صورت فعال بودن ، غیرفعال میکند.

**نکته: mute و unmute جهت غیرفعال و فعال کردن نوتیفیکیشن یک ترد کاربرد دارد.**


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
* Mute the thread so notification is off for that thread
* @param request {
*            	long threadId : id of the thread
* }
*/
    RequestMuteThread requestMuteThread = new RequestMuteThread.Builder()
            .threadId(threadId)
            .build();
    chat.muteThread(requestMuteThread);


    /**
* It Un mutes the thread so notification is off for that thread
*
* @param request {
*            	long threadId : id of the thread
*            	}
*/
    RequestMuteThread muteThread = new RequestMuteThread.Builder()
            .threadId(threadId)
            .build();
    chat.unMuteThread(muteThread);

```

# [IOS](#tab/ios)

``` java
// Request
// an example of muteThread request:

// this is the model that you have to create to pass it through the "muteThread" method
let inputModel = MuteAndUnmuteThreadRequestModel(subjectId:  1101,  //
                                                 typeCode:   nil,   //
                                                 uniqueId:   nil)   //

Chat.sharedInstance.muteThread(muteThreadInput: inputModel, uniqueId: { (muteThreadUniqueId) in
  // "muteThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (muteThreadResponse) in
  // this response is of type "MuteUnmuteThreadModel" but you have to froce cast it as below
  let myResponseModel: MuteUnmuteThreadModel = muteThreadResponse as! MuteUnmuteThreadModel
})

```

# [Android](#tab/android)

``` java
/**
* Mute the thread so notification is off for that thread
* @param request {
*            	long threadId : id of the thread
* }
* @param handler : its not useful yet. set it to null
*/
    RequestMuteThread requestMuteThread = new RequestMuteThread.Builder()
            .threadId(threadId)
            .build();
    chat.muteThread(requestMuteThread);


    /**
* It Un mutes the thread so notification is off for that thread
*
* @param request {
*            	long threadId : id of the thread
*            	}
* @param handler : its not useful yet. set it to null
*/
    RequestMuteThread muteThread = new RequestMuteThread.Builder()
            .threadId(threadId)
            .build();
    chat.unMuteThread(muteThread,null);


```

# [JavaScript](#tab/javascript)

``` javascript
var data = {
    subjectId: 11 //{**REQUIRED**}
}

Chat.muteThread(data, function(result) {
    console.log("Threaded has been successfully muted!");
    console.log(result);
});

```

<div class="tab-end">
</div>

<br/>

### نمایش اعضای یک ترد

با دریافت آیدی ترد و تنظیمات صفحه بندی ، اعضای آن ترد را نشان میدهد.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
   /**
     *
     * @param creatorCoreUserId    if it sets to '0' its considered as it was'nt set   Optional]
     * @param partnerCoreUserId    if it sets to '0' its considered as it was'nt set -
     *                             it gets threads of p2p not groups   Optional]
     * @param partnerCoreContactId if it sets to '0' its considered as it was'nt set-
     *                             it gets threads of p2p not groups   Optional]
     * @param count                Count of the list   Optional]
     * @param offset               Offset of the list  [Optional]
     * @param threadIds             List of thread ids that you want to get  [Optional]
     * @param threadName            Name of the thread that you want to get  [Optional]
     */

RequestThread requestThread = new RequestThread.Builder()
.partnerCoreContactId()
.threadIds()
.threadName()
.partnerCoreContactId()
.creatorCoreUserId()
.partnerCoreUserId()
.count()
.offset()
.build();

getThreads(requestThread)
```

# [IOS](#tab/ios)

``` java
// Request
// an example of getThreadParticipants request:

// this is the model that you have to create to pass it through the "getThreadParticipants" method
let inputModel = GetThreadParticipantsRequestModel(admin:           nil,   //
                                                   count:           5,     //
                                                   firstMessageId:  nil,   //
                                                   lastMessageId:   nil,   //
                                                   name:            nil,   //
                                                   offset:          0,     //
                                                   threadId:        1330,  //
                                                   typeCode:        nil,   //
                                                   uniqueId:        nil)   //

Chat.sharedInstance.getThreadParticipants(getThreadParticipantsInput: inputModel, uniqueId: { (getThreadParticipantUniqueId) in
  // "getThreadParticipantUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (threadParticipantsServerResponse) in
  // this response is of type "GetThreadParticipantsModel" but you have to froce cast it as below
  let myResponseModel: GetThreadParticipantsModel = threadParticipantsServerResponse as! GetThreadParticipantsModel

}, cacheResponse: { (threadParticipantsCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "GetThreadParticipantsModel". (there is no need to cast is as sth...)
})

```

# [Android](#tab/android)

``` java
/**
     * Get the participant list of specific thread
     * <p>
     *
     * @ param long threadId id of the thread we want to get the participant list
     * @ param long count number of the participant wanted to get
     * @ param long offset of the participant list
     */

RequestThreadParticipant participant = new RequestThreadParticipant.Builder(threadId)
                .count()
                .offset()
                .build();
chat.getThreadParticipants(participant ,null)

```

<div class="tab-end">
</div>

<br/>

### اضافه کردن عضو به ترد

با دریافت آیدی ترد و لیستی از از آیدی مخاطبین (contact Id) ، آنها را به اعضای ترد مربوطه اضافه میکند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
 	* contactIds  List of CONTACT IDs
 	* threadId   Id of the thread that you are {*NOTICE*}admin of that and you are going to
 	* add someone as a participant.
 	*
 	* @param request {
 	*            	long threadId : Id of the thread
 	*            	List<Long> contactIds : list of contact ids that wanted to be add
 	*            	}
 	*/
   	  RequestAddParticipants addParticipants = new RequestAddParticipants
            	.Builder(threadId,contactIds)
            	.build();
    	chat.addParticipants(requestAddParticipants);
```

# [IOS](#tab/ios)

``` java
// Request
// an example of addParticipants request:

// this is the model that you have to create to pass it through the "addParticipants" method
let inputModel = AddParticipantsRequestModel(contacts:  [2202, 952, 1281, 2306],  //
                                             threadId:  1330,                     //
                                             typeCode:  nil,                      //
                                             uniqueId:  nil)                      //

Chat.sharedInstance.addParticipants(addParticipantsInput: inputModel, uniqueId: { (addParticipantsUniqueId) in
  // "addParticipantsUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (addParticipantsResponse) in
  // this response is of type "AddParticipantModel" but you have to froce cast it as below
  let response: AddParticipantModel = addParticipantsResponse as! AddParticipantModel
})

```

# [Android](#tab/android)

``` java
/**
 	* contactIds  List of CONTACT IDs
 	* threadId   Id of the thread that you are {*NOTICE*}admin of that and you are going to
 	* add someone as a participant.
 	*
 	* @param request {
 	*            	long threadId : Id of the thread
 	*            	List<Long> contactIds : list of contact ids that wanted to be add
 	*            	}
 	* @param handler : its not useful yet. set it to null
 	*/
   	  RequestAddParticipants addParticipants = new RequestAddParticipants
            	.Builder(threadId,contactIds)
            	.build();
    	chat.addParticipants(requestAddParticipants, null);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.addParticipants({
    threadId: threadId, //{**REQUIRED**}
    contacts: contacts //type:array {**REQUIRED**}
  }, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### حذف کاربر از ترد

با دریافت آیدی ترد و لیستی از آیدی کاربران (userId)، آنها را از ترد مورد نظر حذف میکند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
    * @param request {
    *                participantIds :  List of PARTICIPANT IDs from Thread's Participants object
    *                threadId      : Id of the thread that we wants to remove their participant
    *                }
    */
RequestRemoveParticipants removeParticipants = new RequestRemoveParticipants
            .Builder(threadId,participantsId)
            .build();

    chat.removeParticipants(requestRemoveParticipants);
```

# [IOS](#tab/ios)

``` java

// Request
// an example of removeParticipants request:

// this is the model that you have to create to pass it through the "removeParticipants" method
let inputModel = RemoveParticipantsRequestModel(contacts:  [1],   //
                                                threadId:  1330,  //
                                                typeCode:  nil,   //
                                                uniqueId:  nil)   //

Chat.sharedInstance.removeParticipants(removeParticipantsInput: inputModel, uniqueId: { (removeParticipantsUniqueId) in
  // "removeParticipantsUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (removeParticipantsResponse) in
  // this response is of type "RemoveParticipantModel" but you have to froce cast it as below
  let response: RemoveParticipantModel = removeParticipantsResponse as! RemoveParticipantModel
})

```

# [Android](#tab/android)

``` java
/**
    * @param request {
    *                participantIds :  List of PARTICIPANT IDs from Thread's Participants object
    *                threadId      : Id of the thread that we wants to remove their participant
    *                }
    * @param handler it should be null
    */
RequestRemoveParticipants removeParticipants = new RequestRemoveParticipants
            .Builder(threadId,participantsId)
            .build();

    chat.removeParticipants(requestRemoveParticipants, handler);

```

# [JavaScript](#tab/javascript)

``` javascript
  /**
   * REMOVE PARTICIPANTS
   * @param threadId {**REQUIRED**}
   * @param participants {Array}  USER ID {**REQUIRED**}
   */  

Chat.removeParticipants({
    threadId: threadId,
    participants: participants
  }, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### حذف کاربر از ترد

با دریافت آیدی ترد ، کاربر را از ترد مربوطه خارج میکند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
    /**
* leaves the thread
*
* @param request{ threadId id of the thread
*                 }
*/
RequestLeaveThread leaveThread = new RequestLeaveThread.Builder(threadId)
        .build();
chat.leaveThread(leaveThread);
```

# [IOS](#tab/ios)

``` java

// Request
// an example of leaveThread request:

// this is the model that you have to create to pass it through the "leaveThread" method
let inputModel = LeaveThreadRequestModel(content:   nil,   //
                                         threadId:  1343,  //
                                         typeCode:  nil,   //
                                         uniqueId:  nil)   //

Chat.sharedInstance.leaveThread(leaveThreadInput: inputModel, uniqueId: { (leaveThreadUniqueId) in
	// "leaveThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (leaveThreadResponse) in
	// this response is of type "CreateThreadModel" but you have to froce cast it as below
	let myResponseModel: CreateThreadModel = leaveThreadResponse as! CreateThreadModel
})

```

# [Android](#tab/android)

``` java
    /**
* leaves the thread
*
* @param request{ threadId id of the thread
*                 }
* @param handler it should be null
*/
RequestLeaveThread leaveThread = new RequestLeaveThread.Builder(threadId)
        .build();
chat.leaveThread(leaveThread,null);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.leaveThread({
    threadId: threadId //{**REQUIRED**}
  }, function(result) {
    console.log(result);
  });


```

<div class="tab-end">
</div>

<br/>

### createThreadWithMessage

ساخت یک ترد ، شامل ساخت ترد نفر به نفر (چت دو نفره) ، یا ترد جمعی (گروه) می باشد. در حالت عادی نحوه ی ایجاد هر دو مدل یکسان است ، تفاوت در تعداد نفرات گروه نسبت به ترد دو نفره میباشد.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
 RequestThreadInnerMessage requestThreadInnerMessage = new RequestThreadInnerMessage
                .Builder()
                .message(message)
                .build();

 RequestCreateThread requestCreateThread = new RequestCreateThread
                .Builder(ThreadType, Invitees)
                .message(requestThreadInnerMessage)
                .build();
        chat.createThreadWithMessage(requestCreateThread);
```

# [IOS](#tab/ios)

``` java

// Request
// an example of creatThreadWithMessage request:

// this is the model that you have to create to pass it through the "creatThreadWithMessage" method
let inviteeArray: [Invitee] = [Invitee(id:      "099****27",                                    //
                                       idType:  InviteeVOidTypes.TO_BE_USER_CELLPHONE_NUMBER)]  //

let inputModel = CreateThreadWithMessageRequestModel(threadDescription:           nil,                         //
                                                     threadImage:                 nil,                         //
                                                     threadInvitees:              inviteeArray,                //
                                                     threadMetadata:              nil,                         //
                                                     threadTitle:                 "title",                     //
                                                     threadType:                  ThreadTypes.NORMAL,          //
                                                     messageForwardedMessageIds:  nil,                         //
                                                     messageForwardedUniqueIds:   nil,                         //
                                                     messageMetaData:             nil,                         //
                                                     messageRepliedTo:            nil,                         //
                                                     messageSystemMetaData:       nil,                         //
                                                     messageText:                 "This is The Message Text",  //
                                                     messageType:                 nil,                         //
                                                     typeCode:                    nil,
                                                     uniqueId:                    nil)                    

Chat.sharedInstance.creatThreadWithMessage(creatThreadWithMessageInput: inputModel, uniqueId: { (createWithSendMessageUniqeuId) in
  // "createThreadUniqeuId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (createThreadResponse) in
  // this response is of type "CreateThreadModel" but you have to froce cast it as below
  let myResponseModel: CreateThreadModel = createThreadResponse as! CreateThreadModel

}, onSent: { (isSent) in
  // when the message sends successfully, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let sentModel: SendMessageModel = isSent as! SendMessageModel

}, onDelivere: { (isDeliver) in
  // when the message is delivered, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let deliverModel: SendMessageModel = isDeliver as! SendMessageModel

}, onSeen: { (isSeen) in
  // when the message is seen, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let seenModel: SendMessageModel = isSeen as! SendMessageModel
})

```

# [Android](#tab/android)

``` java
{
  'hasError:' false,
  'errorMessage:' '',
  'errorCode:' 0,
  'result:' {
    'thread:' {
      'id:' 82,
      'joinDate:' undefined,
      'title:' undefined,
      'inviter:' undefined,
      'participants:' undefined,
      'time:' undefined,
      'lastMessage:' undefined,
      'lastParticipantName:' undefined,
      'group:' undefined,
      'partner:' undefined,
      'image:' undefined,
      'unreadCount:' undefined,
      'lastMessageId:' undefined,
      'lastMessageVO:' undefined,
      'partnerLastMessageId:' undefined,
      'partnerLastDeliveredMessageId:' undefined,
      'type:' undefined,
      'metadata': undefined,
      'mute:' undefined,
      'participantCount:' undefined,
      'canEditInfo:' undefined
    }
  }
}

```

<div class="tab-end">
</div>

<br/>

### پاک کردن پیام‌های یک ترد

با دریافت آیدی ترد ، تمامی مسیج های داخل ترد را پاک میکند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
* Required param : threadId 
**/
RequestClearHistory requestClearHistory = new RequestClearHistory
                .Builder(threadId)
                .build();

        chat.clearHistory(requestClearHistory);
```

# [JavaScript](#tab/javascript)

``` javascript
    /**
     * CLEAR THREAD HISTORY
     * @param threadId
     */

    chatAgent.clearHistory({
        threadId: 1431
    }, function(result) {
        console.log("Clear history result", result);
    });

```

<div class="tab-end">
</div>

<br/>

### لیست مدیران یک ترد

با دریافت آیدی ترد و تنظیمات صفحه بندی ، لیست مدیران آن ترد را نشان میدهد.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
 RequestGetAdmin requestGetAdmin = new RequestGetAdmin
                .Builder(5941)
                .build();

        chatController.getAdminList(requestGetAdmin);
```


# [JavaScript](#tab/javascript)

``` javascript
chatAgent.getThreadAdmins({
     threadId: 1431
}, function(result){
     console.log("Get Thread Admins result", result);
});  

```

<div class="tab-end">
</div>

<br/>

### setRole

با دریافت آیدی ترد و لیستی از پارتیسیپنت هایی که میخواهید به عنوان مدیر ترد ثبت شوند، مدیران جدید را به ترد اضافه یا حذف می نماید.
چنان چه پارامتر roleOperation با مقدار add فرستاده شود فرد مورد نظر با Role های ارسال شده به لیست مدیرات ترد اضافه میگردد. و چنان مقدار پارامتر roleOperation برابر با remove باشد ، لیست Role هایی که همراه ان ارسال شده اند از فرد مورد نظر گرفته میشوند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
 * SET ADMIN
 * @param threadId
 * @param userId
 * @param roles
 */

 RequestRole requestRole = new RequestRole();
        requestRole.setId(1181);
        requestRole.setRoleTypes(new ArrayList<String>() {{
            add(RoleType.THREAD_ADMIN);
        }});
        requestRole.setRoleOperation(RoleOperation.ADD);


        ArrayList<RequestRole> requestRoleArrayList = new ArrayList<>();
        requestRoleArrayList.add(requestRole);

        RequestAddAdmin requestAddAdmin = new RequestAddAdmin
                .Builder(5941, requestRoleArrayList)
                .build();

        chatController.setAdmin(requestAddAdmin);
```

# [IOS](#tab/ios)

``` java

// Request
// an example of setRole request:

// this is the model that you have to create to pass it through the "setRole" method
let inputModel = SetRoleRequestModel(roles:           [Roles.CHANGE_THREAD_INFO, Roles.EDIT_MESSAGE_OF_OTHERS],  //
                                     roleOperation:   RoleOperations.Add,  //
                                     threadId:        1330,                //
                                     userId:          2244,                //
                                     typeCode:        nil,                 //
                                     uniqueId:        nil)                 //

Chat.sharedInstance.setRole(setRoleInput: [inputModel], uniqueId: { (setRoleUniqueId) in
  // "setRoleUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (setRoleServerResponse) in
  // this response is of type "UserRolesModel" but you have to froce cast it as below
  let myResponseModel = setRoleServerResponse as! UserRolesModel

}, cacheResponse: { (setRoleCacheResponse) in
  // this it the cache response of this request
  // output of this response is of type "UserRolesModel". (there is no need to cast is as sth...)
})

```

<div class="tab-end">
</div>

<br/>

### spamPvThread

با دریافت آیدی مربوط به یک ترد ، آن ترد را اسپم میکنم.

ورودی:
برای پر کردن پارامترهای ورودی این متد، از روش زیر میتوانید این کار را انجام دهید:
ساختن یک مدل از کلاس SpamPvThreadRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد spamPvThread .
 
خروجی:
در خروجی این متد، ۲ تا  completion handler داریم:
اولی، uniqueId این درخواست شما رو بصورت یک String برمیگرداند.
دومی، جواب سرور به این ریکوئست را ۳ بار بصورت زیر برمیگرداند:
 ThreadModel (بابت ترک ترد)، ‌BlockModel (بابت بلاک کردن ترد)، ClearHistoryModel (بابت پاک کردن چت‌های داخل ترد)

 
<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java

// Request
// an example of spamPvThread request:

// this is the model that you have to create to pass it through the "spamPvThread" method
let inputModel = SpamPvThreadRequestModel(threadId:  2,    //
                                          typeCode:  nil,  //
                                          uniqueId:  nil)  //

Chat.sharedInstance.spamPvThread(spamPvThreadInput: inputModel, uniqueId: { (spamPvThreadUniqueId) in
  // "spamPvThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (spamThreadResponse) in

  // this response is of type "ThreadModel" that you have to froce cast it as below
  if let leaveThreadResponse = spamThreadServerResponseModel as? ThreadModel {
    self.responseCallback?(leaveThreadResponse)

  // this response is of type "BlockedContactModel" that you have to froce cast it as below
  } else if let blockThreadResponse = spamThreadServerResponseModel as? BlockedContactModel  {
    self.responseCallback?(blockThreadResponse)

  // this response is of type "ClearHistoryModel" that you have to froce cast it as below
  } else if let clearHistoryResponse = spamThreadServerResponseModel as? ClearHistoryModel {
    self.responseCallback?(clearHistoryResponse)
  }

})

```

<div class="tab-end">
</div>

<br/>

### messageDeliveryList

با فراخوانی این متد، میتوانید لیست افرادی که پیام شما به آن‌ها رسیده را ببینید.
 
<br/>

ورودی:
برای پر کردن پارامترهای ورودی این متد، از روش زیر میتوانید این کار را انجام دهید:
ساختن یک مدل از کلاس MessageDeliverySeenListRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد messageDeliveryList .
 
<br/>

خروجی:
در خروجی این متد، ۲ تا  completion handler داریم:
اولی، uniqueId این درخواست شما رو بصورت یک String برمیگرداند.
دومی، پاسخ این درخواست را از نوع GetThreadParticipantsModel بازمیگرداند.
 
مثالی از فراخوانی این متد:



<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java

// Request
// an example of messageDeliveryList request:

// this is the model that you have to create to pass it through the "messageDeliveryList" method
let inputModel = MessageDeliverySeenListRequestModel(count:       40,      //
                                                     messageId:   134453,  //
                                                     offset:      0,       //
                                                     typeCode:    nil,     //
                                                     uniqueId:    nil)     //

Chat.sharedInstance.messageDeliveryList(messageDeliveryListInput: inputModel, uniqueId: { (deliveryListUniqueId) in
  // "deliveryListUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, completion: { (deliverListResponse) in
  // this response is of type "GetThreadParticipantsModel" but you have to froce cast it as below
  let myResponseModel = deliverListResponse as! GetThreadParticipantsModel
})

```

<div class="tab-end">
</div>

<br/>

### messageSeenList

با فراخوانی این متد، میتوانید لیست افرادی که پیام شما را خوانده اند را ببینید.
 
<br/>

ورودی:
برای پر کردن پارامترهای ورودی این متد، از روش زیر میتوانید این کار را انجام دهید:
ساختن یک مدل از کلاس MessageDeliverySeenListRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد messageSeenList .
 
<br/>

خروجی:
در خروجی این متد، ۲ تا  completion handler داریم:
اولی، uniqueId این درخواست شما رو بصورت یک String برمیگرداند.
دومی، پاسخ این درخواست را از نوع GetThreadParticipantsModel بازمیگرداند.
 
مثالی از فراخوانی این متد:



<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java

// Request
// an example of messageSeenList request:

// this is the model that you have to create to pass it through the "messageSeenList" method
let inputModel = MessageDeliverySeenListRequestModel(count:       40,      //
                                                     messageId:   134453,  //
                                                     offset:      0,       //
                                                     typeCode:    nil,     //
                                                     uniqueId:    nil)     //

Chat.sharedInstance.messageSeenList(messageSeenListInput: inputModel, uniqueId: { (seenListUniqueId) in
  // "seenListUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, completion: { (seenListResponse) in
  // this response is of type "GetThreadParticipantsModel" but you have to froce cast it as below
  let myResponseModel = seenListResponse as! GetThreadParticipantsModel
})

```

<div class="tab-end">
</div>






<div class="box-end">
</div>


## مدیریت پیام ها

### sendTextMessage

ارسال پیام به یک ترد، با دریافت آیدی ترد و پیغام ارسالی. این متد لیستی شامل سه callback function دریافت میکند که برای مدیریت کاربر پس از ارسال پیغام(send) ، دریافت (deliver) و دیده شدن پیغام ارسالی توسط دیگر اعظای ترد(seen) است.

<br/>

**نکته: **

سرویس پیام رسان (ارسال کننده ی پیغام)، تحویل پیغام به گیرنده را (از طریق متد deliver) به کاربر(فرستنده ی پیغام)اعلام میکند.(Event Listeners)

<br/>

کاربر دریافت کننده ی پیغام باید رویت پیغام را از طریق متد seen به سرور(فرستنده ی پیغام) اعلام کند.

<div class="tab-start">
</div>

# [java](#tab/java)

``` java
textMessage = "your text message."; //Required
threadId = 83; //Required

/**
     * Its sent message but it gets Object as an attribute
     *
     * @param requestMessage {
     *                       String textMessage : text of the message
     *                       int messageType : type of the message
     *                       String jsonMetaData : metadata of the message
     *                       long threadId : The id of a thread that its wanted to send
     *                       }
     */	
RequestMessage message = new RequestMessage
                .Builder(textMessage,threadId)
                .build();
chat.sendTextMessage(requestMessage,);


```

# [IOS](#tab/ios)

``` java

// Request
// an example of sendTextMessage request:

// this is the model that you have to create to pass it through the "sendTextMessage" method
let inputModel = SendTextMessageRequestModel(content:         "text message",  //
                                             metaData:        metadata,        //
                                             repliedTo:       nil,             //
                                             systemMetadata:  nil,             //
                                             threadId:        1328,            //
                                             typeCode:        nil,             //
                                             uniqueId:        nil)             //

Chat.sharedInstance.sendTextMessage(sendTextMessageInput: inputModel, uniqueId: { (sendTextMessageUniqueId) in
  // "sendTextMessageUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, onSent: { (isSent) in
  // when the message sends successfully, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let sentModel: SendMessageModel = isSent as! SendMessageModel

}, onDelivere: { (isDeliver) in
  // when the message is delivered, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let deliverModel: SendMessageModel = isDeliver as! SendMessageModel

}, onSeen: { (isSeen) in
  // when the message is seen, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let seenModel: SendMessageModel = isSeen as! SendMessageModel
})

```

# [Android](#tab/android)

``` java
textMessage = "your text message."; //Required
threadId = 83; //Required

/**
     * Its sent message but it gets Object as an attribute
     *
     * @param requestMessage {
     *                       String textMessage : text of the message
     *                       int messageType : type of the message
     *                       String jsonMetaData : metadata of the message
     *                       long threadId : The id of a thread that its wanted to send
     *                       }
     * @param handler        @param handler Its not useful yet.set it to null
     */	
RequestMessage message = new RequestMessage
                .Builder(textMessage,threadId)
                .build();
chat.sendTextMessage(requestMessage, null);



```

# [JavaScript](#tab/javascript)

``` javascript
  sendChatParams = {
    threadId: threadId,  //{**REQUIRED**}
    content: message  //{**REQUIRED**}
  };

  Chat.send(sendChatParams, {
    onSent: function(result) {
       //your_code_for_sent_msg_in_app
      //console.log("\nYour message has been Sent!\n"); 
      console.log(result);
    },
    onDeliver: function(result) {
      //your_code_for_delivered_msg_in_app
      //console.log("\nYour message has been Delivered!\n"); 
      console.log(result);
    },
    onSeen: function(result) {
      //your_code_for_seen_msg_in_app
      //console.log("\nYour message has been Seen!\n"); 
      console.log(result);
    }
  });

```

<div class="tab-end">
</div>

<br/>

### editMessage

با دریافت آیدی پیغام و متن جدید پیغام ، پیغام مربوطه را تغییر میدهد.

**نکته: سرور نتیجه ی تغییر پیغام را بر روی رویداد "onEditedMessage" گزارش خواهد داد.**


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
messageId = 514; //Required
messageContent = "edited message"; //Required

/**
 	* Message can be edit when you pass the message id and the edited
 	* content in order to edit your Message.
 	*
 	* @param request {
 	*            	String messageContent : content of them message
 	*            	long messageId : id of the message it wanted to be edit
 	*            	String metaData : metaData of the message
 	*            	}
 	*/
   	 equestEditMessage editMessage = new RequestEditMessage.
            	Builder(messageContent,messageId)
            	.metaData()
            	.build();
    	chat.editMessage(editMessage);
```

# [IOS](#tab/ios)

``` java

// Request
// an example of editMessage request:

// this is the model that you have to create to pass it through the "editMessage" method
let inputModel = EditTextMessageRequestModel(content:         "text message",  //
                                             metaData:        nil,             //
                                             repliedTo:       nil,             //
                                             subjectId:       10799,           //
                                             typeCode:        nil,             //
                                             uniqueId:        nil)             //

Chat.sharedInstance.editMessage(editMessageInput: inputModel, uniqueId: { (editMessageUniqueId) in
  // "editMessageUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, completion: { (editMessageResponse) in
  // this response is of type "EditMessageModel" but you have to froce cast it as below
  let myResponseModel = editMessageResponse as! EditMessageModel
})

```

# [Android](#tab/android)

``` java
messageId = 514; //Required
messageContent = "edited message"; //Required

/**
 	* Message can be edit when you pass the message id and the edited
 	* content in order to edit your Message.
 	*
 	* @param request {
 	*            	String messageContent : content of them message
 	*            	long messageId : id of the message it wanted to be edit
 	*            	String metaData : metaData of the message
 	*            	}
 	* @param handler : its not useful yet. set it to null  
 	*/
   	 equestEditMessage editMessage = new RequestEditMessage.
            	Builder(messageContent,messageId)
            	.metaData()
            	.build();
    	chat.editMessage(editMessage,null);

```

# [JavaScript](#tab/javascript)

``` javascript
  editChatParams = {
    messageId: messageId,  //{**REQUIRED**}
    content: newMessage  //{**REQUIRED**}
  };

  Chat.editMessage(editChatParams, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### replyMessage

با دریافت آیدی ترد ، آیدی پیام ، و محتوای دلخواه ، پیام مورد نظر شما را انتخاب و محتوا را در پاسخ به آن پیام ارسال میکند.

<br/>

با توجه به اینکه جنس این متد همانند sendTextMessage از نوع ارسال پیام است ، در نتیجه سه callback جهت عملیات پس از ارسال، دریافت، و دیده شدن پیام لازم خواهد داشت.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
threadId = threadId; //Required
repliedTo = messageId; //Required
content = message; //Required

	  /**
 	*
 	* @param request{ messageContent content of the reply message
 	*             	threadId   	id of the thread
 	*             	messageId  	message id of the message that we want to reply
 	*             	metaData   	meta data of the message
 	*             	}
 	*/
   		      	RequestReplyMessage requestReplyMessage = new RequestReplyMessage
            	.Builder(messageContect,threadId,messageId)
            	.messageType()
            	.systemMetaData()
            	.build();
    	chat.replyMessage(request);
```

# [IOS](#tab/ios)

``` java

// Request
// an example of replyMessage request:

// this is the model that you have to create to pass it through the "replyMessage" method
let inputModel = ReplyTextMessageRequestModel(content:      "text message",  //
                                             metaData:      nil,             //
                                             repliedTo:     15397,           //
                                             subjectId:     1133,            //
                                             typeCode:      nil,             //
                                             uniqueId:      nil)             //

Chat.sharedInstance.replyMessage(replyMessageInput: inputModel, uniqueId: { (replyMessageUniqueId) in
	// "replyMessageUniqueId" is uniqueId of this request, that sends back to the client as a callback
	// do whatever you want with this unique Id

}, onSent: { (isSent) in
  // when the message sends successfully, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let sentModel: SendMessageModel = isSent as! SendMessageModel

}, onDelivere: { (isDeliver) in
  // when the message is delivered, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let deliverModel: SendMessageModel = isDeliver as! SendMessageModel

}, onSeen: { (isSeen) in
  // when the message is seen, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let seenModel: SendMessageModel = isSeen as! SendMessageModel
})

```

# [Android](#tab/android)

``` java
threadId = threadId; //Required
repliedTo = messageId; //Required
content = message; //Required

	  /**
 	* Reply the message in the current thread and send az message and receive at the
 	* <p>
 	*
 	* @param request{ messageContent content of the reply message
 	*             	threadId   	id of the thread
 	*             	messageId  	message id of the message that we want to reply
 	*             	metaData   	meta data of the message
 	*             	}
 	* @param handler : its not useful yet. set it to null
 	*/
   		      	RequestReplyMessage requestReplyMessage = new RequestReplyMessage
            	.Builder(messageContect,threadId,messageId)
            	.messageType()
            	.systemMetaData()
            	.build();
    	chat.replyMessage(request, handler);

```

# [JavaScript](#tab/javascript)

``` javascript
  replyChatParams = {
    threadId: threadId, //{**REQUIRED**}
    repliedTo: messageId, //{**REQUIRED**}
    content: message //{**REQUIRED**}
  };

  Chat.replyMessage(replyChatParams, {
    onSent: function(result) {
      //console.log(result.uniqueId + " \t has been Sent! (Reply)");
       console.log(result);
    },
    onDeliver: function(result) {
      //console.log(result.uniqueId + " \t has been Delivered! (Reply)"); 
    },
    onSeen: function(result) {
      //console.log(result.uniqueId + " \t has been Seen! (Reply)"); 
    }
  });

```

<div class="tab-end">
</div>

<br/>

### forwardMessage

این متد ، پیام(هایی) را به یک ترد مقصد ارسال میکند. نوع این متد نیز ارسال پیام است.

**نکته: متد باز ارسال‌‌، لیستی از پیام ها را با دریافت آیدی پیام ها به ترد مقصد ارسال میکند. در این حالت برای هر پیام یک uniqueId جداگانه خواهد بود.**


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/* Required fields */
/*  threadId 
 *  messageIds
*/

 /**
 	* forward message to some thread
 	*
 	* @param request {
 	*            	threadId : destination thread id
 	*            	messageIds : List of message ids that we want to forward them
 	*            	}
 	*/
   	 RequestForwardMessage requestForwardMessage = new RequestForwardMessage
            	.Builder(threadId,messageIds)
            	.build();
    	chat.forwardMessage(request);

```

# [IOS](#tab/ios)

``` java

// Request
// an example of forwardMessage request:

// this is the model that you have to create to pass it through the "forwardMessage" method
let inputModel = ForwardMessageRequestModel(messageIds:    [15395],   //
                                            metaData:      nil,       //
                                            repliedTo:     nil,       //
                                            subjectId:     1133,      //
                                            typeCode:      nil)       //

Chat.sharedInstance.forwardMessage(forwardMessageInput: inputModel, uniqueIds: { (uniqueIdArr) in
  // "uniqueIdArr" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, onSent: { (isSent) in
  // when the message sends successfully, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let sentModel: SendMessageModel = isSent as! SendMessageModel

}, onDelivere: { (isDeliver) in
  // when the message is delivered, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let deliverModel: SendMessageModel = isDeliver as! SendMessageModel

}, onSeen: { (isSeen) in
  // when the message is seen, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let seenModel: SendMessageModel = isSeen as! SendMessageModel
})

```

# [Android](#tab/android)

``` java
/* Required fields */
/*  threadId 
 *  messageIds
*/

 /**
 	* forward message to some thread
 	*
 	* @param request {
 	*            	threadId : destination thread id
 	*            	messageIds : List of message ids that we want to forward them
 	*            	}
 	*/
   	 RequestForwardMessage requestForwardMessage = new RequestForwardMessage
            	.Builder(threadId,messageIds)
            	.build();
    	chat.forwardMessage(request);


```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.forwardMessage({
    subjectId: destination, //threadId {**REQUIRED**}
    content: JSON.stringify(messageIds)  //{**REQUIRED**}
  }, {
    onSent: function(result) {
      //console.log(result.uniqueId + " \t has been Sent! (FORWARD)");
      console.log(result);
    },
    onDeliver: function(result) {
      console.log(result.uniqueId + " \t has been Delivered! (FORWARD)");
    },
    onSeen: function(result) {
      console.log(result.uniqueId + " \t has been Seen! (FORWARD)");
    }
  });

```

<div class="tab-end">
</div>

<br/>

### sendFileMessage

ارسال پیام با محتوای فایل به یک ترد مشخص. با دریافت آیدی ترد مقصد، آدرس فایل مورد نظر، محتوای متن همراه عکس و محتوای مورد نظر متادیتا، فایل ارسالی را پس از آپلود بر روی سرور، به همراه پیام ارسالی به ترد مقصد ارسال میکند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/* Required fields */
 *  threadId
 *  filePath
*/

/**
 	* This method first check the type of the file and then choose the right
 	* server and send that
 	* <p>
 	*
 	* @param requestFileMessage {description	Its the description that you want to send with file in the thread
 	*                        	filePath    	path of the file that you want to send to thread
 	*                        	threadId   	Id of the thread that you want to send file
        *                        	systemMetaData [optional]

                                      }
 	*/
     RequestFileMessage fileMessage = new RequestFileMessage.
            	Builder(threadId,filePath)
            	.messageType()
            	.systemMetadata()
            	.build();
   	 
      	 
    	chat.sendFileMessage(requestFileMessage);
```

# [IOS](#tab/ios)

``` java
// Request
// an example of sendFileMessage request:

// this is the model that you have to create to pass it through the "sendFileMessage" method
let inputModel = SendFileMessageRequestModel(fileName:        "newPic",          //
                                             imageName:       nil,               //
                                             xC:              nil,               //
                                             yC:              nil,               //
                                             hC:              nil,               //
                                             wC:              nil,               //
                                             threadId:        1101,              //
                                             content:         "empty message",   //
                                             metaData:        nil,               //
                                             repliedTo:       nil,               //
                                             subjectId:       1101,              //
                                             fileToSend:      data,              //
                                             imageToSend:     nil,               //
                                             typeCode:        nil,               //
                                             uniqueId:        nil)               //

Chat.sharedInstance.sendFileMessage(sendFileMessageInput: inputModel, uniqueId: { (sendFileMessageUniqueId) in
  // "sendFileMessageUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, uploadProgress: { (progress) in
  // this is a Double between 0 and 1, that respresent the upload progress

}, onSent: { (isSent) in
  // when the message sends successfully, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let sentModel: SendMessageModel = isSent as! SendMessageModel

}, onDelivere: { (isDeliver) in
  // when the message is delivered, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let deliverModel: SendMessageModel = isDeliver as! SendMessageModel

}, onSeen: { (isSeen) in
  // when the message is seen, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let seenModel: SendMessageModel = isSeen as! SendMessageModel
})

```

# [Android](#tab/android)

``` java
/* Required fields */
 *  threadId
 *  fileUri
*/

/**
 	* This method first check the type of the file and then choose the right
 	* server and send that
 	* <p>
 	*
 	* @param requestFileMessage {description	Its the description that you want to send with file in the thread
 	*                        	fileUri    	Uri of the file that you want to send to thread
 	*                        	threadId   	Id of the thread that you want to send file
 	*                        	systemMetaData [optional]}
 	* @param handler        	handler    	it is for send file message with progress
 	*/
     RequestFileMessage fileMessage = new RequestFileMessage.
            	Builder(activity,threadId,fileUri)
            	.messageType()
            	.systemMetadata()
            	.build();
   	 
      	 
    	chat.sendFileMessage(requestFileMessage, handler);

```

# [JavaScript](#tab/javascript)

``` javascript
Chat.sendFileMessage({
    threadId: threadId, //{**REQUIRED**}
    file: file, //{**REQUIRED**}
    content: caption,
    metaData: metaData
}, {
    onSent: function(result) {
        console.log(result.uniqueId + " \t has been Sent!");
},
    onDeliver: function(result) {
        console.log(result.uniqueId + " \t has been Delivered!");
},
    onSeen: function(result) {
        console.log(result.uniqueId + " \t has been Seen!");
    }
});

```

<div class="tab-end">
</div>

<br/>

### deleteMessage

با دریافت آیدی پیام (messageId) ، پیام مربوطه را حذف خواهد کرد.

<br/>

نکته: در صورتی که متغیر deleteForAll را با مقدار true پر کنید ، پیام مذکور از تاریخچه ی ترد همه ی اعضای آن ترد پاک خواهد شد.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/* Required fields */
/*  messageId 
*/


/**
 	*
 	* @param request {
 	*             	ArrayList<Long> messageIds;
 	*             	boolean deleteForAll : If you want to delete message for everyone you can set it true if u don't want
 	* you can set it false 
 	*            	}
  	*/
   	  RequestDeleteMessage requestDeleteMessage = new RequestDeleteMessage.Builder()
            	.messageIds()
            	.deleteForAll()
            	.build();
    	chat.deleteMessage(deleteMessage);
```

# [IOS](#tab/ios)

``` java
// Request
// an example of deleteMessage request:

// this is the model that you have to create to pass it through the "deleteMessage" method
let inputModel = DeleteMessageRequestModel(deleteForAll:    nil,    //
                                           subjectId:       10799,  //
                                           typeCode:        nil,    //
                                           uniqueId:        nil)    //

Chat.sharedInstance.deleteMessage(deleteMessageInput: inputModel, uniqueId: { (deleteMEssageUniqueId) in
  // "deleteMEssageUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, completion: { (deleteMessageResponse) in
  // this response is of type "DeleteMessageModel" but you have to froce cast it as below
  let myResponseModel = deleteMessageResponse as! DeleteMessageModel
})

```

# [Android](#tab/android)

``` java
/* Required fields */
/*  messageId 
*/


/**
 	*
 	* @param request {
 	*             	ArrayList<Long> messageIds;
 	*             	boolean deleteForAll : If you want to delete message for everyone you can set it true if u don't want
 	* you can set it false 
 	*            	}
 	* @param handler : its not useful yet. set it to null
 	*/
   	  RequestDeleteMessage requestDeleteMessage = new RequestDeleteMessage.Builder()
            	.messageIds()
            	.deleteForAll()
            	.build();
    	chat.deleteMessage(deleteMessage, handler);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.deleteMessage({
    messageId: messageId, //{**REQUIRED**}
    deleteForAll: deleteForAll 
  }, function(result) {
    console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### eplyFileMessage

پاسخ پیام با محتوای فایل به یک ترد مشخص. با دریافت آیدی ترد مقصد، آدرس فایل مورد نظر، محتوای متن همراه عکس و محتوای مورد نظر متادیتا، فایل ارسالی را پس از آپلود بر روی سرور، به همراه پیام ارسالی به ترد ارسال میکند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
 	* messageContent content of the reply message
 	* threadId   	id of the thread
 	* messageId  	of the message that we want to reply
 	* metaData   	meta data of the message
 	*
 	* @param request {
 	*            	String messageContent : content of the reply message
 	*            	long threadId : id of the thread
 	*            	long messageId : message id of the message that wanted to be reply
 	*            	String systemMetaData : meta data of the message
 	*            	String filePath: Path of the file
 	*            	int messageType : Type of the message
 	*            	}
 	* @param handler
 	*/
     RequestReplyFileMessage replyFileMessage = new RequestReplyFileMessage
    	.Builder(messageContent,threadId,messageId,filePath)
    	.messageType()
    	.systemMetaData()
    	.build();
         	
    chat.replyFileMessage(request, handler);
```

# [IOS](#tab/ios)

``` java
// Request
// an example of sendFileMessage request:

// this is the model that you have to create to pass it through the "sendFileMessage" method
let inputModel = SendFileMessageRequestModel(fileName:        "newPic",          //
                                             imageName:       nil,               //
                                             xC:              nil,               //
                                             yC:              nil,               //
                                             hC:              nil,               //
                                             wC:              nil,               //
                                             threadId:        1101,              //
                                             content:         "empty message",   //
                                             metaData:        nil,               //
                                             repliedTo:       nil,               //
                                             subjectId:       1101,              //
                                             fileToSend:      data,              //
                                             imageToSend:     nil,               //
                                             typeCode:        nil,               //
                                             uniqueId:        nil)               //

Chat.sharedInstance.sendFileMessage(sendFileMessageInput: inputModel, uniqueId: { (sendFileMessageUniqueId) in
  // "sendFileMessageUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, uploadProgress: { (progress) in
  // this is a Double between 0 and 1, that respresent the upload progress

}, onSent: { (isSent) in
  // when the message sends successfully, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let sentModel: SendMessageModel = isSent as! SendMessageModel

}, onDelivere: { (isDeliver) in
  // when the message is delivered, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let deliverModel: SendMessageModel = isDeliver as! SendMessageModel

}, onSeen: { (isSeen) in
  // when the message is seen, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let seenModel: SendMessageModel = isSeen as! SendMessageModel
})

```

# [Android](#tab/android)

``` java
/**
 	* Reply the message in the current thread and send az message and receive at the
 	* <p>
 	* messageContent content of the reply message
 	* threadId   	id of the thread
 	* messageId  	of the message that we want to reply
 	* metaData   	meta data of the message
 	*
 	* @param request {
 	*            	String messageContent : content of the reply message
 	*            	long threadId : id of the thread
 	*            	long messageId : message id of the message that wanted to be reply
 	*            	String systemMetaData : meta data of the message
 	*            	Uri fileUri : Uri of the file
 	*            	Activity activity
 	*            	int messageType : Type of the message
 	*            	}
 	* @param handler
 	*/
     RequestReplyFileMessage replyFileMessage = new RequestReplyFileMessage
    	.Builder(messageContent,threadId,messageId,fileUri,activity)
    	.messageType()
    	.systemMetaData()
    	.build();
         	chat.replyFileMessage(request, handler);

```


<div class="tab-end">
</div>

<br/>

### getMessageSeenList

گرفتن لیست افرادی که پیام را دیده اند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
* Gets the list of the participant that the message is seen
*
* @param requestParams {
*                  	long messageId : Id of the message
*                  	}
*/
    RequestSeenMessageList seenMessageList = new RequestSeenMessageList
            .Builder(messageId)
            .build();
    chat.getMessageSeenList(seenMessageList);
```


# [Android](#tab/android)

``` java
    /**
 	* Gets the list of the participant that the message is seen
 	*
 	* @param requestParams {
 	*                  	long messageId : Id of the message
 	*                  	}
 	*/
   	  RequestSeenMessageList seenMessageList = new RequestSeenMessageList
            	.Builder(messageId)
            	.build();
    	chat.getMessageSeenList(seenMessageList);

```

<div class="tab-end">
</div>

<br/>

### getMessageDeliveredList

گرفتن لیست افرادی که پیام به آنها رسیده است.

<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
* Gets the list of the person that the message has been delivered to them
*
* @param requestParams {
*                  	long messageId : Id of the message
*                  	}
*/    
    RequestDeliveredMessageList requestDeliveredMessageList = new RequestDeliveredMessageList
            .Builder(messageId)
            .build();
    chat.getMessageDeliveredList(requestDeliveredMessageList);
```


# [Android](#tab/android)

``` java
/**
* Gets the list of the person that the message has been delivered to them
*
* @param requestParams {
*                  	long messageId : Id of the message
*                  	}
*/    
    RequestDeliveredMessageList requestDeliveredMessageList = new RequestDeliveredMessageList
            .Builder(messageId)
            .build();
    chat.getMessageDeliveredList(requestDeliveredMessageList);

```

<div class="tab-end">
</div>

<br/>

### deleteMultipleMessages

با دریافت آیدی چند پیام (messageIds) ، پیام های مربوطه را حذف خواهد کرد.

**نکته: در صورتی که متغیر deleteForAll را با مقدار true پر کنید ، پیام مذکور از تاریخچه ی ترد همه ی اعضای آن ترد پاک خواهد شد.**

<br/>

**برای IOS:**

ورودی:
برای پر کردن پارامترهای ورودی این متد، از روش زیر میتوانید این کار را انجام دهید:
ساختن یک مدل از کلاس DeleteMultipleMessagesRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد deleteMultipleMessages .
 
خروجی:
در خروجی این متد، ۲ تا  completion handler داریم:
اولی، uniqueId این درخواست شما رو بصورت یک String برمیگرداند.
دومی، پاسخ این درخواست را از نوع DeleteMessageModel بازمیگرداند.
 
تنها تفاوت این متد با متد قبلی (deleteMessages) در این است که در پارامترهایی ورودی،‌ یک آرایه مسیج‌آیدی و یوینیک آیدی میگیرد.

<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/*
* Required param
*              ArrayList<Long> messageIds
*/
        RequestDeleteMessage requestDeleteMessage = new RequestDeleteMessage
                .Builder(messageIds)
                .deleteForAll()
                .build();

        chat.deleteMultipleMessage(requestDeleteMessage);
```


# [Android](#tab/android)

``` java


```

# [JavaScript](#tab/javascript)

``` javascript
chatAgent.deleteMultipleMessages({
    threadId: 10298,
    messageIds: [47710, 47709, 47708],
    deleteForAll: true
}, function(result) {
    console.log("Delete Multiple Message Result", result);
});

```

<div class="tab-end">
</div>

<br/>

### cancelMessage

با استفاده از از این متد میتوانید پیام‌هایی که ارسال کردید اما هنوز ارسال نشده اند (پیام‌هایی که داخل صف قرار میگیرند و میتوانید اون‌ها رو با فراخوانی متد getHistory ببینید) رو کنسل کنید.

<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java

// Request
// an example of cancelMessage request:

// this is the model that you have to create to pass it through the "cancelSendMessage" method
let inputModel = CancelMessageRequestModel(textMessageUniqueId:       "xxxyyyyyyzzzzzzzzz",  //
                                           editMessageUniqueId:       nil,                   //
                                           forwardMessageUniqueId:    nil,                   //
                                           fileMessageUniqueId:       nil,                   //
                                           uploadImageUniqueId:       nil,                   //
                                           uploadFileUniqueId:        nil)                   //

Chat.sharedInstance.cancelSendMessage(cancelMessageInput: inputModel, completion: { (isSuccessfull) in
  // this response is of type "Boolean"
})

```

# [Android](#tab/android)

``` java

    /**
* It cancels message if its still in the Queue
*/
chat.cancelMessage(uniqueId);

```

<div class="tab-end">
</div>

<br/>

### startTyping

هنگامی که کاربر شروع به تایپ کردن میکند، میتوانید با فراخوانی این متد، پیغام isTyping را واسه اعضای دیگر ترد بفرستید.
 
**نکته: در نظر داشته باشید که حتما بعد از اینکه تایپ کردن کاربر به پایان رسید، متد stopTyping را فراخوانی کنید.**


<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java

// Request
// an example of startTyping request:

Chat.sharedInstance.startTyping(threadId: 1244:, { (startTypingUniqueId) in
  // "startTypingUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // hold this uniqueId, because you'll need this id when calling the 'stopTyping'
})

```


<div class="tab-end">
</div>

<br/>

### stopTyping

هنگامی که تایپ کردن کاربر به پایان رسید، این متد را فراخوانی کنید.

<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java

// Request
// an example of stopTyping request:

Chat.sharedInstance.stopTyping(uniqueId: "zzzzzzyyyyyyxxxx)
```

<div class="tab-end">
</div>

<br/>

### getHistory

با دریافت آیدی مربوط به یک ترد ، تاریخچه ی آن را بر اساس تنظیمات صفحه بندی (count,offset) نشان خواهد داد.


<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java

// Request
// an example of getHistory request:

// this is the model that you have to create to pass it through the "getHistory" method
let inputModel = GetHistoryRequestModel(count:               2,    //
                                        firstMessageId:      nil,  //
                                        fromTime:            nil,  //
                                        lastMessageId:       nil,  //
                                        messageId:           nil,  //
                                        metadataCriteria:    nil,  //
                                        offset:              nil,  //
                                        order:               nil,  //
                                        query:               nil,  //
                                        threadId:            128,  //
                                        toTime:              nil,  //
                                        typeCode:            nil,  //
                                        uniqueId:            nil)  //

Chat.sharedInstance.getHistory(getHistoryInput: inputModel, uniqueId: { (getHistoryUniqueId) in
  // "getHistoryUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (getHistoryServerResponse) in
  // this response is of type "GetHistoryModel" but you have to froce cast it as below
  let myResponseModel: GetHistoryModel = getHistoryServerResponse as! GetHistoryModel

}, cacheResponse: { (getHistoryCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "GetHistoryModel". (there is no need to cast is as sth...)

}, textMessagesNotSent: { ([QueueOfWaitTextMessagesModel]) in
  // this response contain all messages that has not sent yet!
  // you have to cast it as [QueueOfWaitTextMessagesModel]

}, editMessagesNotSent: { ([QueueOfWaitEditMessagesModel]) in
  // this response contain all edite messages that has not sent yet!
  // you have to cast it as [QueueOfWaitEditMessagesModel]

}, forwardMessagesNotSent: { ([QueueOfWaitForwardMessagesModel]) in
  // this response contain all forward messages that has not sent yet!
  // you have to cast it as [QueueOfWaitForwardMessagesModel]

}, fileMessagesNotSent: { ([QueueOfWaitFileMessagesModel]) in
  // this response contain all file messages that has not sent yet!
  // you have to cast it as [QueueOfWaitFileMessagesModel]

}, uploadImageNotSent: { ([QueueOfWaitUploadImagesModel]) in
  // this response contain all uploadImage requests that has not sent yet!
  // you have to cast it as [QueueOfWaitUploadImagesModel]

}, uploadFileNotSent: { ([QueueOfWaitUploadFilesModel]) in
  // this response contain all uploadFile requests that has not sent yet!
  // you have to cast it as [QueueOfWaitUploadFilesModel]
})

```


<div class="tab-end">
</div>




<div class="box-end">
</div>


## مکانیزم Seen برای پیام ها

جهت اینکه برای پیام های ارسالی در یک ترد، به فرستنده،  پیام Seen ارسال شود. لازم است کلاینت از تابع chatAgent.seen() استفاده نماید.
 
 <br/>

چنانچه کلاینت آنلاین بوده و در داخل یک ترد در حال گفتگو باشد میتواند به محض مشاهده ی پیام برای پیام دیده شده Seen ارسال کند. اما اگرتعدادی پیام در یک ترد ارسال شده و کاربر بعد از مدتی وارد ترد شود، بایستی برای آخرین پیام دریافتی Seen ارسال کند.
 
 <br/>
 
* **تبصره**: برای جلوگیری از ارسال Seen تکراری برای آخرین مسیج ترد، کلاینت میتواند از مقادیر lastSeenMessageId و lastSeenMessageTime و مقایسه این مقادیر با ID یا Time مسیجی که میخواهد برای آن Seen بفرستد، از ارسال Seen اضافی جلوگیری نماید.

 <br/>
 
### سناریوهای Seen شدن اتوماتیک برای پیام ها در سرور
 
 <br/>
 
- زمانی که کاربر برای یک پیام، Seen ارسال میکند، سرور چت بصورت اتوماتیک، مقدار seen تمامی پیام های قبل از این پیام را True ست میکند. لذا کلاینت نیز باید بعد از ارسال Seen برای یک مسیج، تغییرات مد نظر خود برای نمایش Seen خوردن مسیج را برای تمامی مسیج های قبلی نیز اعمال نماید.
 
- چنانچه کاربر در یک ترد مسیجی ارسال کند، مقدار Seen برای تمامی مسیج های دریافتی اش در سرور به True تغییر میکند. لذا همانند حالت قبل، کلاینت باید UI خود را با این فرض بروزرسانی کند.
- 

<div class="box-end">
</div>

## مدیریت Cache

ساختار کش برای SDK بصورت کاملا داخلی پیاده سازی شده و نیازی به پیاده سازی دوباره ی کش برای چت نیست. مقادیر کش تماما با استفاده از کلیدهای دریافت شده برای کاربر از سمت سرور SSO رمزنگاری شده اند و امکان سو استفاده از مقادیر کش شده بر روی سیستم وجود ندارد. چنانچه کاربری سعی بر دسترسی به مقادیر کش شده با کلید نادرست نماید، تمامی مقادیر برای حفظ امنیت کاربر از روی کش پاک میشوند.  کش با استفاده از IndexedDb پیاده سازی شده و ساختار جداول به صورت زیر میباشد:

``` javascript
users: '&id, name, cellphoneNumber, keyId',
contacts: '[owner+id], id, owner, uniqueId, userId, cellphoneNumber, email, firstName, lastName, expireTime',
threads: '[owner+id] ,id, owner, title, time, [owner+time]',
participants: '[owner+id], id, owner, threadId, notSeenDuration, admin, name, contactName, email, expireTime',
messages: '[owner+id], id, owner, threadId, time, [threadId+id], [threadId+owner+time]',
messageGaps: '[owner+id], [owner+waitsFor], id, waitsFor, owner, threadId, time, [threadId+owner+time]'

```
**نکته: جهت بهره برداری از سیستم کش، بایستی مقدار پارامتر enableCache در پارامترهای اولیه ی ورودی SDK چت به صورت True ست نمائید.**

### clearCacheDatabasesOfUser

سیستم کش پادچت بصورت چندین کاربره طراحی شده و چنانچه چندین کاربر با یک سیستم از چت استفاده نمایند، اطلاعات هرکدام با استفاده از کلیدهای رمزنگاری خود آن کاربر بر روی دیتابیس های کش ذخیره میشود. 

چنانچه بخواهید اطلاعات کش شده ی مربوط به کاربر جاری را از کش پاک کنید، کافیست متد clearCacheDatabasesOfUser را فراخوانی نمائید.

``` javascript
chatAgent.clearCacheDatabasesOfUser();
```

### deleteCacheDatabases 

چنانچه بخواهید اطلاعات کش شده ی مربوط به تمامی کاربران را از کش پاک کنید، کافیست متد deleteCacheDatabases را فراخوانی نمائید. این متد تمامی جداول کش را حذف نموده و دوباره میسازد.

<div class="box-end">
</div>

``` javascript
chatAgent.deleteCacheDatabases();
```

## مدیریت فایل ها

### uploadImage

با دریافت آدرس فایل عکس ، آن را بر روی سرور فایل ذخیره میکند.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
RequestUploadImage requestUploadImage = new RequestUploadImage.Builder(filePath)
                .xC(0)
                .yC(0)
                .hC(200)
                .wC(100)
                .build();

chat.uploadImage(requestUploadImage);
```

# [IOS](#tab/ios)

``` java
// Request
// an example of uploadImage request:

// this is the model that you have to create to pass it through the "uploadImage" method
let inputModel = UploadImageRequestModel(dataToSend:        data,      //
                                         fileExtension:     nil,       //
                                         fileName:          "newPic",  //
                                         fileSize:          nil,       //
                                         originalFileName:  nil,       //
                                         threadId:          nil,       //
                                         xC:                nil,       //
                                         yC:                nil,       //
                                         hC:                nil,       //
                                         wC:                nil,       //
                                         typeCode:          nil,       //
                                         uniqueId:          nil)       //

Chat.sharedInstance.uploadImage(uploadImageInput: inputModel, uniqueId: { (UploadImageUniqueId) in
  // "UploadImageUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, progress: { (progress) in
  // this is a Double between 0 and 1, that represents the upload progress

}, completion: { (response) in
  // this response is of type "UploadImageModel" but you have to force cast it as below
  let responseModel: UploadImageModel = response as! UploadImageModel
})

```

# [Android](#tab/android)

``` java
chat.uploadImage(Context context, Activity activity, Uri fileUri);

RequestUploadImage requestUploadImage = new RequestUploadImage.Builder(activity,fileUri)
                .build();

chat.uploadImage(requestUploadImage);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.uploadImage({
    image: "/your/image/path",
    xC: xC,
    yC: yC,
    hC: hC,
    wC: wC
  }, function(result) {
      console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### uploadFile

با دریافت آدرس فایل آن را در سرور فایل بارگذاری خواهد کرد.


<div class="tab-start">
</div>

# [java](#tab/java)

``` java
/**
     * @param requestUploadFile {
     *                          Activity activity
     *                          String filePath : path of the file
     *                          }
     */		
RequestUploadFile uploadFile = new RequestUploadFile.Builder(filePath)
                .build();
        chat.uploadFile(uploadFile);
```

# [IOS](#tab/ios)

``` java
// Request
// an example of uploadFile request:

// this is the model that you have to create to pass it through the "uploadFile" method
let inputModel = UploadFileRequestModel(dataToSend:        data,      //
                                        fileExtension:     nil,       //
                                        fileName:          "newPic",  //
                                        fileSize:          nil,       //
                                        originalFileName:  nil,       //
                                        threadId:          nil,       //
                                        typeCode:          nil,       //
                                        uniqueId:          nil)       //

myChatObject?.uploadFile(uploadFileInput: inputModel, uniqueId: { (uploadFileUniqueId) in
  // "uploadFileUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, progress: { (progress) in
  // this is a Double between 0 and 1, that represents the upload progress

}, completion: { (response) in
  // this response is of type "UploadFileModel" but you have to force cast it as below
  let responseModel: UploadFileModel = response as! UploadFileModel
})

```

# [Android](#tab/android)

``` java
/**
     * @param requestUploadFile {
     *                          Activity activity
     *                          Uri fileUri : Uri of the file
     *                          }
     */		
RequestUploadFile uploadFile = new RequestUploadFile.Builder(activity, uri)
                .build();
        chat.uploadFile(uploadFile);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.uploadFile({
    file: file
  }, function(result) {
      console.log(result);
  });

```

<div class="tab-end">
</div>

<br/>

### getFile

با دریافت آیدی فایل ذخیره شده و کد مشخصه ی آن (hashCode) لینک آن را در اختیار قرار میدهد.این متد پارامتری به عنوان downloadable دارد که از نوع boolean است. در صورت مثبت بودن لینک فایل خروجی قابل دانلود خواهد بود.


<div class="tab-start">
</div>


# [IOS](#tab/ios)

``` java
// Request
// an example of getImage request:

// this is the model that you have to create to pass it through the "getImage" method
let inputModel = GetFileRequestModel(downloadable:    true,    //
                                     fileId:          52171,   //
                                     hashCode:        "168232d744d-0.9990232707506134")   //

Chat.sharedInstance.getFile(getFileInput: inputModel, uniqueId: { (getFileUniqueId) in
  // "getFileUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, progress: { (myDownloadProgress) in
  // this is a Double between 0 and 1, that respresent the download progress

}, completion: { (data, response) in
  // "data" is of kind Data, that represents the file itself
  // "response" is the UploadImageModel

}, cacheResponse: { (cacheResponse, filePath) in
  // "cacheResponse" is the UploadFileModel
  // "filePath" is the address of the file in the local project Bundle
})

```

# [Android](#tab/android)

``` java

RequestGetFile requestGetFile = new RequestGetFile
                .Builder(fileId,hashCode,downloadable)
                .build();
        chat.getFile(requestGetFile);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.getFile({
    fileId: fileId,
    hashCode: hashCode,
    downloadable: downloadable
  }, function(result) {
    if (!result.hasError) {
      //your_code
    }
  });

```

<div class="tab-end">
</div>

<br/>

### manageUpload

با فراخوانی این متد میتوانید فایل‌ (یا عکسی) را که در حال آپلود می‌باشد مدیریت کنید. (cancle)


<div class="tab-start">
</div>


# [IOS](#tab/ios)

``` java
// Request
// an example of manageUpload request:

Chat.sharedInstance.manageUpload(image:         false,      //
                                 file:          true,       //
                                 withUniqueId:  "xxxxxxxyyyyyyyyzzzzzzz",    //
                                 withAction:    DownloaUploadAction.cancel,  //
                                 completion:    { (responseMessage, isSuccesfull) in
  // "responseMessage" is of type String
  // "isSuccesfull" is the Boolean
})

```

<div class="tab-end">
</div>

<br/>

### manageDownload

با فراخوانی این متد میتوانید فایل‌ (یا عکسی) را که در حال دانلود می‌باشد مدیریت کنید. (suspend , resume, cancle)


<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java
// Request
// an example of manageDownload request:

Chat.sharedInstance.manageDownload(withUniqueId:  "xxxxxxxyyyyyyyyzzzzzzz",    //
                                   withAction:    DownloaUploadAction.cancel,  //
                                   completion:    { (responseMessage, isSuccesfull) in
  // "responseMessage" is of type String
  // "isSuccesfull" is the Boolean
})

```

<div class="tab-end">
</div>

<br/>

### manageDownload

با فراخوانی این متد میتوانید فایل‌ (یا عکسی) را که در حال دانلود می‌باشد مدیریت کنید. (suspend , resume, cancle)
 

<div class="tab-start">
</div>

# [IOS](#tab/ios)

``` java
// Request
// an example of manageDownload request:

Chat.sharedInstance.manageDownload(withUniqueId:  "xxxxxxxyyyyyyyyzzzzzzz",    //
                                   withAction:    DownloaUploadAction.cancel,  //
                                   completion:    { (responseMessage, isSuccesfull) in
  // "responseMessage" is of type String
  // "isSuccesfull" is the Boolean
})

```

<div class="tab-end">
</div>

<br/>

### uploadFileProgress 

با استفاده از این متد می توانید مقدار بایتی را که در حال آپلود شدن است را با استفاده از اینترفیس ProgressHandler.onProgress دنبال کنید. 

<div class="tab-start">
</div>

# [Android](#tab/android)

``` java
 /**
     * It uploads file and it shows progress of the file downloading
     *
     * @param requestUploadFile {
     *                          Activity activity
     *                          Uri fileUri
     *                          }
     * @param handler           {
     *                          onProgress
     *                          onFinish
     *                          onError
     *                          }
     */
	  RequestUploadFile uploadFile = new RequestUploadFile.Builder(activity, uri)
                .build();

        chat.uploadFileProgress(uploadFile, new ProgressHandler.onProgressFile() {
            @Override
            public void onFinish(String imageJson, FileUpload fileImageUpload) {
                
            }

            @Override
            public void onError(String jsonError, ErrorOutPut error) {
                
            }

            @Override
            public void onProgress(String uniqueId, int bytesSent, int totalBytesSent, int totalBytesToSend) {
                
            }
            
        });

```

<div class="tab-end">
</div>


<div class="box-end">
</div>

## مدیریت پروفایل

### getUserInfo

این متد اطلاعات پروفایل کاربر را در اختیارش قرار میدهد. با توجه به توکن دسترسی عمل میکند، لذا نیازی به ورودی ندارد.


<div class="tab-start">
</div>


# [IOS](#tab/ios)

``` java

// Request
// an example of getUserInfo request:

// this is the model that you have to create to pass it through the "getUserInfo" method
Chat.sharedInstance.getUserInfo(uniqueId: { (getUserInfoUniqueId) in
  // "getContactUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, completion: { (userInfoServerResponse) in
  // this response is of type "UserInfoModel" but you have to froce cast it as below
  let myResponseModel: UserInfoModel = userInfoServerResponse as! UserInfoModel

}, cacheResponse: { (userInfoCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "UserInfoModel". (there is no need to cast is as sth...)
})

```

# [Android](#tab/android)

``` java
chat.getUserInfo(null);

```

# [JavaScript](#tab/javascript)

``` javascript
  Chat.getUserInfo(function(userInfo) {
    console.log(userInfo);
  });
```

<div class="tab-end">
</div>

<br/>

### isTyping

این متد دارای دو بخش متفاوت میباشد. در کل هدف ارسال بسته هایی شامل اطلاعات فرد در حال تایپ به سرور میباشد که سرور بتواند طرفین مقابل را از وضعیت تایپ کردن یوزر مطلع سازد.

<br/>

برای استفاده از این امکان، کافیست همزمان با شروع تایپ توسط کاربر متد startTyping فراخوانی شده و مقدار threadId بدان ارسال شود. به صورت زیر: 

**javaScript:**

``` javascript
chatAgent.startTyping({threadId: 1431});
```
با فراخوانی متد startTyping به صورت اتوماتیک هر 1 ثانیه یکبار پیامی حاوی اطلاعات لازم برای سرور ارسال میگردد. در صورتی که عملیات تایپ کردن توسط کاربر به اتمام رسید. میتوانید با فراخوانی متد stopTyping طرفین مقابل و سرور را از این موضوع باخبر سازید. به صورت زیر:


``` javascript
chatAgent.stopTyping();
```

<div class="box-end">
</div>

## Event Listeners

رویدادهایی که از طریق پکیج چت اعلام میشوند شامل جدول زیر است.

||||
|--- |--- |--- |
|ردیف|توضیحات|متد|
|۱|زمانی که پیغام ارسالی شما به گیرنده برسد این رویداد فراخوانی میشود|onDeliver|
|۲|در پاسخ به درخواست دریافت لیست مخاطبین|onGetContacts|
|۳|پس از درخواست دریافت تاریخچه ی ترد|onGetHistory|
|۴|پس از درخواست دریافت لیست تردها|onGetThread|
|۵|پس از دیده شدن پیام ارسالی|onSeen|
|۶|پس از غیرفعال کردن نوتیفیکیشن یک ترد|onMuteThread|
|۷|پس از فعال کردن نوتیفیکیشن یک ترد|onUnmuteThread|
|۹|پس از ارسال پیام|onSent|
|۱۰|پس از ساخته شدن یک ترد جدید اعلام میشود|onCreateThread|
|۱۱|پس از درخواست دریافت لیست اعضای یک ترد|onGetThreadParticipant|
|۱۲|پس از ویرایش یک پیام|onEditedMessage|
|۱۳|پس از اضافه کردن مخاطب جدید|onContactAdded|
|۱۴|پس از حذف یک مخاطب|onRemoveContact|
|۱۵|پس از تغییر عنوان یک ترد|onRenameThread|
|۱۶|پس از همگام سازی مخاطبین|onSyncContact|
|۱۷|پس از اضافه شدن عضو جدید به ترد|onThreadAddParticipant|
|۱۸|پس از حذف یک عضو از ترد|onThreadRemoveParticipant|
|۱۹|پس از خروج یکی از اعضای ترد|onThreadLeaveParticipant|
|۲۰|پس از حذف یک پیام|onDeleteMessage|
|۲۲|پس از دریافت پیام جدید در هر ترد|onNewMessage|
|۲۳|پس از ویرایش اطلاعات مخاطب|onUpdateContact|
|۲۴|پس از آپلود شدن فایل|onUploadFile|
|۲۵|پس از آپلود تصویر|onUploadImageFile|
|۲۶|پس از تغییر وضعیت اتصال به سرور|onChatState|
|۲۹|پس از مسدود سازی یک مخاطب|onBlock|
|۳۰|پس از درخواست دریافت لیست مخاطبین مسدود شده|onGetBlockList|
|۳۱|پس از غیرفعال کردن انسداد یک مخاطب|onUnBlock|
|۳۲|پس از جستجوی مخاطب|onSearchContact|
|۳۳|پس از رخداد یک خطا|onError|

<br/>

### Andoid

جهت دسترسی به هر یک از این event ها باید به این صورت عمل کنید:

``` java
chat.addListener(new ChatAdapter() {
            @Override
            public void onSeen(String content) throws IOException {
                super.onSeen(content);
            }
        });

```

یا کلاس خود را از ChatAdapter ارث بری کنید:

``` java
public class MyActivity extends ChatAdapter {
.
.
.
    @Override
    public void onSeen(String content) throws IOException {
        Log.d("RAW_MESSAGE", content);
        super.onSeen(content);
        .
        .
        .
     }
.
.
}

```

### IOS

با ساختن پکیج چت،‌ و همچنین تایید کردن ChatDelegate ، شما باید متدهای زیر را در کلاس خود، پیاده سازی کنید.
این ها رویدادهایی هستند که از طریق پکیج چت اعلام میشوند.

رخداد تمامی رویداد ها با متدهای زیر قابل دریافت خواهند بود.


``` java
func messageEvents(type: String, result: JSON) { }
func threadEvents(type: String, result: JSON) { }
func chatError(errorCode: Int, errorMessage: String, errorResult: Any?) { }
func chatState(state: Int) { }
func chatConnected() { }
func chatReconnect() { }
func chatThreadEvents() { }
func chatReady() { }
func chatDeliver(messageId: Int, ownerId: Int) { }

```


#### messageEvents

تمامی رویدادهایی که پس از فعل و انفعال پیام ها قابل رخداد است با این نام قابل دریافت است.
message events یا رویدادهای پیام دلایل مختلفی دارد ، که به فراخور آن میتوانید عملیات مورد نظر خود را سمت اپلیکیشن انجام دهید.
این رویداد، ۲ مقدار به شما برمیگرداند؛ یکی تایپ و دیگری محتوای مربوطه

انواع تایپ های رویداد messageEvents عبارتند از:

- MESSAGE_NEW: با دریافت پیام جدید این رویداد رخ خواهد داد.
- MESSAGE_EDIT: ویرایش شدن یک پیغام در ترد، از طریق این رویداد به اعضای آن ترد اطلاع داده میشود.
- MESSAGE_DELIVERY: دریافت پیام توسط گیرنده توسط این رویداد به فرستنده اطلاع رسانی میشود.
- MESSAGE_SEEN: پس از دیده شدن پیغام توسط کاربر گیرنده ی پیام ، فرستنده توسط این رویداد از این امر مطلع میشود.

<br/>

شما میتوانید با توجه به تایپ دریافتی، محتوای فرستاده شده در قسمت دوم را دریافت و عملیات متناسب را سمت اپلیکیشن خود انجام دهید.

#### threadEvents

تمامی رویداد های ترد هایی که کاربر در آن عضو است یا به آن مرتبط می باشد از این طریق اعلام میشود.
رویدادهای مربوط به ترد ، انواع زیر را داراست که بسته به نوع آن می توانید عملیات متناسب را سمت اپلیکیشن خود انجام دهید:

- THREAD_NEW: ساخت ترد جدید را به اعضایی که در آن مشارکت خواهند داشت (Participants) اعلام میکند.
- THREAD_LAST_ACTIVITY_TIME: زمانی که فعل و انفعالی در یک ترد رخ دهد، زمان آخرین فعل و انفعال رخ داده به اعضای آن ترد اعلام خواهد شد.(اپلیکیشن جهت آپدیت لیست تردها بر اساس جدیدترین تغییرات آنها میتواند اقدام کند)
- THREAD_ADD_PARTICIPANTS: اضافه شدن فرد جدید به یک ترد را به همه ی اعضا اعلام میکند.
- THREAD_LEAVE_PARTICIPANTS: ترک کردن ترد توسط یک فرد را به اعضا اعلام میکند.
- THREAD_REMOVE_PARTICIPANTS: حذف شدن یک فرد از ترد را به اعضا اعلام میکند.
- THREAD_REMOVED_FROM: حذف شدن یک فرد از ترد را به او اعلام میکند.
- THREAD_RENAME: تغییر نام ترد توسط این رویداد به هر یک از اعضا اعلام میشود.
- THREAD_MUTE: پس از غیرفعال کردن نوتیفیکیشن یک ترد توسط کاربر به او اعلام میشود.
- THREAD_UNMUTE: پس از فعال کردن نوتیفیکیشن یک ترد توسط کاربر به او اعلام میشود.
- THREAD_INFO_UPDATED: در صورتی که اطلاعات داخل ترد نیاز به به روز رسانی داشته باشد (مثل زمانی که یک پیغام پاک میشود)، توسط این رویداد به دیگر اعضا اطلاع رسانی میشود.
- THREAD_UNREAD_COUNT_UPDATED: تعداد پیغام های خوانده نشده ی هر ترد توسط این رویداد به اعضای آن اعلام میشود.اپلیکیشن میتواند در لیست ترد های نمایش داده به کاربر ، تعداد پیغام های خوانده نشده ی هر کدام را اعلام کند.در صورتی که پیغام جدیدی به هر تردی اضافه شود ، تعداد پیغام های خوانده نشده ی آن آپدیت و بدین وسیله به کاربر (اعضای آن ترد) گزارش میشود.
 
 #### chatError
 تمامی خطا ها از سمت سرور توسط این رویداد به کاربر گزارش میشود.

 #### chatState

 تغییر وضعیت ارتباط با سرور پیام رسان را به کاربر اطلاع میدهد.
 
چهار وضعیت CONNECTED , CONNECTING , CLOSED , CLOSING قابل رخداد است.

### JavaScript

#### متد on:

رخداد تمامی رویداد ها با متد on قابل دریافت خواهد بود. رویداد های قابل مشاهده شامل موارد زیر است:

#### messageEvents:

تمامی رویدادهایی که پس از فعل و انفعال پیام ها قابل رخداد است با این نام قابل دریافت است. message events یا رویدادهای پیام دلایل مختلفی دارد ، که به فراخور آن میتوانید عملیات مورد نظر خود را سمت اپلیکیشن انجام دهید.

``` javascript
/**
 * Listen to Message Events
 */
Chat.on("messageEvents", function(event) {
  var type = event.type,
    message = event.result.message;

  console.log(event);

  switch (type) {
    case "MESSAGE_NEW":
      /**
       * Sending Message Seen to Sender after 5 secs
       */
      setTimeout(function() {
        Chat.seen({messageId: message.id, ownerId: message.ownerId});
      }, 5000);

      break;

    case "MESSAGE_EDIT":
      //your_code
      break;

    case "MESSAGE_DELIVERY":
      break;

    case "MESSAGE_SEEN":
      break;

    default:
      break;
  }
});


```

message events شامل event های زیر است:

- MESSAGE_NEW: با دریافت پیام جدید این رویداد رخ خواهد داد.
- MESSAGE_EDIT: ویرایش شدن یک پیغام در ترد، از طریق این رویداد به اعضای آن ترد اطلاع داده میشود.
- MESSAGE_DELIVERY: دریافت پیام توسط گیرنده توسط این رویداد به فرستنده اطلاع رسانی میشود.
- MESSAGE_SEEN: پس از دیده شدن پیغام توسط کاربر گیرنده ی پیام ، فرستنده توسط این رویداد از این امر مطلع میشود.


#### threadEvents:

تمامی رویداد های ترد هایی که کاربر در آن عضو است یا به آن مرتبط میباشد از این طریق اعلام میشود. رویدادهای مربوط به ترد ، انواع زیر را داراست که بسته به نوع آن میتوانید عملیات متناسب را سمت اپلیکیشن خود انجام دهید.

- THREAD_NEW: ساخت ترد جدید را به اعضایی که در آن مشارکت خواهند داشت (Participants) اعلام میکند.
- THREAD_LAST_ACTIVITY_TIME: زمانی که فعل و انفعالی در یک ترد رخ دهد، زمان آخرین فعل و انفعال رخ داده به اعضای آن ترد اعلام خواهد شد.(اپلیکیشن جهت آپدیت لیست تردها بر اساس جدیدترین تغییرات آنها میتواند اقدام کند)
- THREAD_ADD_PARTICIPANTS: اضافه شدن فرد جدید به یک ترد را به همه ی اعضا اعلام میکند.
- THREAD_LEAVE_PARTICIPANTS: ترک کردن ترد توسط یک فرد را به اعضا اعلام میکند.
- THREAD_REMOVE_PARTICIPANTS: حذف شدن یک فرد از ترد را به اعضا اعلام میکند.
- THREAD_REMOVED_FROM: حذف شدن یک فرد از ترد را به او اعلام میکند.
- THREAD_RENAME: تغییر نام ترد توسط این رویداد به هر یک از اعضا اعلام میشود.
- THREAD_MUTE: پس از غیرفعال کردن نوتیفیکیشن یک ترد توسط کاربر به او اعلام میشود.
- THREAD_UNMUTE: پس از فعال کردن نوتیفیکیشن یک ترد توسط کاربر به او اعلام میشود.
- THREAD_INFO_UPDATED: در صورتی که اطلاعات داخل ترد نیاز به به روز رسانی داشته باشد (مثل زمانی که یک پیغام پاک میشود)، توسط این رویداد به دیگر اعضا اطلاع رسانی میشود.
- THREAD_UNREAD_COUNT_UPDATED: تعداد پیغام های خوانده نشده ی هر ترد توسط این رویداد به اعضای آن اعلام میشود.اپلیکیشن میتواند در لیست ترد های نمایش داده به کاربر ، تعداد پیغام های خوانده نشده ی هر کدام را اعلام کند.در صورتی که پیغام جدیدی به هر تردی اضافه شود ، تعداد پیغام های خوانده نشده ی آن آپدیت و بدین وسیله به کاربر (اعضای آن ترد) گزارش میشود.


``` javascript
/**
 * Listen to Thread Events
 */
Chat.on("threadEvents", function(event) {
  var type = event.type;

  switch (type) {
    case "THREAD_LAST_ACTIVITY_TIME":
      //your_code_here
      break;

    case "THREAD_NEW":
      //your_code_here
      break;

    case "THREAD_ADD_PARTICIPANTS":
      //your_code_here
      break;

    case "THREAD_REMOVE_PARTICIPANTS":
      //your_code_here
      break;

    case "THREAD_LEAVE_PARTICIPANT":
      //your_code_here
      break;

    case "THREAD_REMOVED_FROM":
      //your_code_here
      break;

    case "THREAD_RENAME":
      //your_code_here
      break;

    case "THREAD_MUTE":
      //your_code_here
      break;

    case "THREAD_UNMUTE":
      //your_code_here
      break;

    case "THREAD_INFO_UPDATED":
      //your_code_here
      break;

    case "THREAD_UNREAD_COUNT_UPDATED":
      //your_code_here
      break;

    default:
      break;
  }
});

```

#### error:
تمامی خطا ها از سمت سرور توسط این رویداد به کاربر گزارش میشود.


``` javascript
/**
* Listen to Error Messages
*/
Chat.on("error", function(error) {
  console.log("ERROR \t", error.code, error.message, error.error);
});

```

#### chatState:
تغییر وضعیت ارتباط با سرور پیام رسان را به کاربر اطلاع میدهد.

چهار وضعیت CONNECTED,CONNECTING,CLOSED,CLOSING قابل رخداد است.

``` javascript
/**
* Listen to Chat State Changes
*/
chatAgent.on("chatState", function(chatState) {
// your_code
});

```

<div class="box-end">
</div>


## آدرس ها و تنظیمات

تنظیمات و آدرس های زیر برای اتصال به سرور چت(به روی سرور سندباکس) از طریق صف باید به عنوان پارامتر ورودی پس از ساخت نمونه ی اولیه از پکیج، به متد connect داده شود تا اتصال با سرور انجام گیرد.

<div class="tab-start">
</div>

# [java](#tab/java)

``` java
  queueServer= "*****" // {*REQUIRED*} Activemq's address
  queuePort = "*****" // {*REQUIRED*} Activemq's port
  queueInput = "THE_INPUT_QUEUE" // {*REQUIRED*} The name of input queue assigned to you
  queueOutput= "THE_OUTPUT_QUEUE" // {*REQUIRED*} The name of output queue assigned to you
  queueUserName = "*****" // {*REQUIRED*} 
  queuePassword = "*****"  // {*REQUIRED*} 
  ssoHost = "https://accounts.pod.ir" // {*REQUIRED*} SSO Server Address
  platformHost = "https://sandbox.pod.ir:8043" // {*REQUIRED*} Platform Server Address
  fileServer = "https://sandbox.pod.ir:8443" // {*REQUIRED*} File Server Address
  serverName = "chat-server" // {*REQUIRED*} Server to register on
  token = "CLIENT_ACCESS_TOKEN" // {*REQUIRED*} SSO Token

chat.connect(socketServerAddress, appId, serverName, token , ssoHost, platformHost, fileServer)
```

# [IOS](#tab/ios)

``` java
// SandBox Addresses:
let socketAddress	= "wss://chat-sandbox.pod.ir/ws"			// Socket Server Address
let serverName		= "chat-server"						// Server to register on
let ssoHost		= "https://accounts.pod.ir"				// SSO Server Address
let platformHost	= "https://sandbox.pod.ir:8043/srv/basic-platform"	// Platform Core Server Address
let fileServer		= "http://sandbox.fanapium.com:8080"			// File Server Address
let token		= "b304d32ec4bd49d5992b90450a644d9e"			// SSO Token

// create Chat object
var myChatObject = Chat(socketAddress:		“Socket Address”,
                     ssoHost:			“SSO Host Address”,
                     platformHost:		”PlatForm Address”,
                     fileServer:		“File Server Address”,
                     serverName:		"chat-server",
                     token:			“TOKEN”,
                     msgPriority:		Int?,
                     msgTTL:			Int?,
                     httpRequestTimeout:	Int?,
                     actualTimingLog:		Bool?,
                     wsConnectionWaitTime:	Double,
                     connectionRetryInterval:	Int,
                     connectionCheckTimeout:	Int,
                     messageTtl:		Int,
                     reconnectOnClose:		Bool)

```

# [Android](#tab/android)

``` java
  socketServerAddress = "wss://chat-sandbox.pod.ir/ws" // {*REQUIRED*} Socket Server Address
  appId = "POD-Chat"  // {*REQUIRED*} Application Id
  ssoHost = "https://accounts.pod.ir" // {*REQUIRED*} SSO Server Address
  platformHost = "https://sandbox.pod.ir:8043/srv/basic-platform" // {*REQUIRED*} Platform Server Address
  fileServer = "https://sandbox.pod.ir:8443/" // {*REQUIRED*} File Server Address
  serverName = "chat-server" // {*REQUIRED*} Server to register on
  token = "CLIENT_ACCESS_TOKEN" // {*REQUIRED*} SSO Token

chat.connect(socketServerAddress, appId, serverName, token , ssoHost, platformHost, fileServer)

```

# [JavaScript](#tab/javascript)

``` javascript
var params = {
    appId: new Date().getTime(),
    socketAddress: 'ws://172.16.110.131:8003/ws', // {**REQUIRED**} Socket Address
    ssoHost: 'http://172.16.110.76', // {**REQUIRED**} Socket Address
    platformHost: 'http://172.16.110.131:8080', // {**REQUIRED**} Platform Core Address
    fileServer: 'http://172.16.110.131:8080', // {**REQUIRED**} File Server Address
    serverName: 'chat-server2', // {**REQUIRED**} Server to to register on
    grantDeviceIdFromSSO: false,
    enableCache: false, // Enable Client side caching
    fullResponseObject: true,
    mapApiKey: 'NESHAN_MAP_API_KEY',
    typeCode: "default",
    token: '7cba09ff83554fc98726430c30afcfc6', // {**REQUIRED**} SSO Token 
    wsConnectionWaitTime: 500, // Time out to wait for socket to get ready after open
    connectionRetryInterval: 5000, // Time interval to retry registering device or registering server
    connectionCheckTimeout: 10000, // Socket connection live time on server
    messageTtl: 24 * 60 * 60, // Message time to live (1 day in seonds)
    reconnectOnClose: true, // auto connect to socket after socket close
    asyncLogging: {
        onFunction: true, // log main actions on console
        onMessageReceive: true, // log received messages on console
        onMessageSend: true, // log sent messaged on console
        actualTiming: true // log actual functions running time
    }
}

```

<div class="tab-end">
</div>




<br/>

پیام­ها را می­توان در سه حالت “همه وضعیت­ها”، “دریافت شده”، “دیده شده” دریافت کرد.
<div class="box-end">
</div>


## موقعیت و مسیریابی

### mapSearch

نام خیابان، اماکن و کسب و کار های ثبت شده و ... (searchTerm) را حول نقطه ی مرجع (مختصات طول و عرض جغرافیایی مرجع با متغیرهای latitude , longitude مشخص میشود) جستجو میکند.


<div class="tab-start">
</div>

# [Android](#tab/android)

``` java
chat.mapSearch(String searchTerm, Double latitude, Double longitude);

```

<div class="tab-end">
</div>

<br/>

### mapRouting

با دریافت دو مختصات مبدا و مقصد بهترین مسیر بین دو نقطه‌ی مشخص را با توجه به ترافیک معابر محاسبه می کند و هر پاسخ ممکن است شامل یک یا چند مسیر باشد. در هر مسیر زمان سفر و مسافت آن محاسبه می‌گردد. مرتب‌سازی مسیرها بر اساس بهترین مسیر از نظر زمان و مسافت خواهد بود.

اولین پارامتر ورودی مختصات نقطه شروع مسیریابی، یا همان مبدا است (origin)، این مختصات باید به صورت latitude,longitude باشد که دو عدد با کاما از هم جدا شده‌اند.
دومین پارامتر ورودی مقصد است (destination) که مختصات نقطه پایان مسیریابی و قالب آن مانند نقطه شروع است.


<div class="tab-start">
</div>

# [Android](#tab/android)

``` java
chat.mapRouting(String origin, String destination);
```

<div class="tab-end">
</div>

<div class="box-end">
</div>

## لینک‌های مرتبط

- [مقدمه](/documents/introduction/)
- [مفاهیم](/documents/concepts/)
- [استاندارد و خطاها](/documents/errors/)
- [شروع به کار](/documents/get-started/)
- [پکیج‌ها](/documents/packages/)

<div class="box-end">
</div>

